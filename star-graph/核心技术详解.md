# AI智绘云平台 - 核心技术详解

## 文档说明

本文档详细讲解AI智绘云平台的核心技术实现，结合实际代码剖析文生图的完整流程。

## 目录

1. [文生图完整流程](#文生图完整流程)
2. [核心技术一：AI服务集成与工作流生成](#核心技术一ai服务集成与工作流生成)
3. [核心技术二：Redis ZSet优先级队列](#核心技术二redis-zset优先级队列)
4. [核心技术三：定时任务调度与信号量控制](#核心技术三定时任务调度与信号量控制)
5. [核心技术四：WebSocket双向通信](#核心技术四websocket双向通信)
6. [核心技术五：乐观锁防并发冲突](#核心技术五乐观锁防并发冲突)
7. [核心技术六：Redis分布式锁与Lua脚本](#核心技术六redis分布式锁与lua脚本)

---

## 文生图完整流程

### 流程图

```
用户提交中文提示词
    ↓
① 冻结积分（防止恶意提交）
    ↓
② Ollama翻译中文→英文
    ↓
③ Freemarker生成ComfyUI工作流JSON
    ↓
④ 任务加入Redis ZSet优先级队列
    ↓
⑤ Spring Task定时扫描队列
    ↓
⑥ 获取Redisson信号量（控制并发）
    ↓
⑦ 提交任务到ComfyUI执行
    ↓
⑧ 后端监听ComfyUI的WebSocket事件
    ↓
⑨ 接收进度/结果，推送给前端
    ↓
⑩ 保存图片到数据库，扣除积分
```

### 详细步骤说明

#### ① 冻结积分

**代码位置：** `Text2ImageServiceImpl.textToImage()`

```java
// 先冻结用户积分，防止用户积分不足或恶意提交
userFundRecordService.pointsFreeze(UserUtils.getUser().getId(), text2ImageReqDto.getSize());
```

**作用：** 防止用户提交任务后积分不足，或恶意大量提交任务

#### ② Ollama翻译

**代码位置：** `Text2ImageServiceImpl.getComfyuiTask()`

```java
// 翻译正向提示词
comfyuiModel.setPropmt("(8k, best quality, masterpiece),(high detailed skin)," 
    + ollamaService.translate(text2ImageReqDto.getPropmt()));

// 翻译负向提示词
comfyuiModel.setReverse(ollamaService.translate(text2ImageReqDto.getReverse()) 
    + ",bad face,naked,bad finger,bad arm,bad leg,bad eye");
```

**作用：** 将中文提示词翻译成英文，ComfyUI模型仅支持英文

#### ③ Freemarker生成工作流JSON

**代码位置：** `FreemarkerServiceImpl.renderText2Image()`

```java
// 使用模板引擎生成ComfyUI工作流JSON
String prompt = freemarkerService.renderText2Image(comfyuiModel);
ComfyuiRequestDto comfyuiRequestDto = new ComfyuiRequestDto(
    Constants.COMFYUI_CLIENT_ID, 
    JSON.parseObject(prompt)
);
```

**作用：** 动态生成ComfyUI工作流配置，避免硬编码

#### ④ 加入Redis ZSet队列

**代码位置：** `RedisServiceImpl.addQueueTask()`

```java
// 获取分布式自增ID作为score
Long score = stringRedisTemplate.opsForValue().increment(DISTRIBUTED_ID_KEY);
// 添加到ZSet队列
stringRedisTemplate.opsForZSet().add(DISTRIBUTED_QUEUE_KEY, comfyuiTask.getId(), score);
// 获取队列序号
Long rank = stringRedisTemplate.opsForZSet().rank(DISTRIBUTED_QUEUE_KEY, comfyuiTask.getId());
comfyuiTask.setIndex(rank != null ? rank + 1 : 1);
```

**作用：** 将任务加入优先级队列，返回队列序号给前端

#### ⑤ Spring Task扫描队列

**代码位置：** `RunTaskJob.task()`

```java
@Scheduled(cron = "*/1 * * * * ?")  // 每秒执行一次
public void task() {
    RLock lock = redissonClient.getLock(SPRING_TASK_LOCK_KEY);
    if (lock.tryLock()) {  // 获取分布式锁
        try {
            if (redisService.hasQueueTask()) {  // 检查队列
                // ... 继续处理
            }
        } finally {
            lock.unlock();
        }
    }
}
```

**作用：** 定时扫描Redis队列，使用分布式锁防止多实例重复执行

#### ⑥ 获取Redisson信号量

**代码位置：** `RunTaskJob.task()`

```java
RSemaphore semaphore = redissonClient.getSemaphore(TASK_RUN_SEMAPHORE);
if (semaphore.tryAcquire()) {  // 尝试获取信号量
    sendTaskToComfyui();  // 提交任务
}
```

**作用：** 控制ComfyUI并发任务数，防止GPU显存溢出

#### ⑦ 提交任务到ComfyUI

**代码位置：** `RunTaskJob.sendTaskToComfyui()`

```java
// 从队列弹出任务
ComfyuiTask comfyuiTask = redisService.popQueueTask();
// 调用ComfyUI API
Call<HashMap> hashMapCall = comfyuiApi.addQueueTask(comfyuiTask.getComfyuiRequestDto());
Response<HashMap> response = hashMapCall.execute();
// 获取promptId并保存
String promptId = (String) response.body().get("prompt_id");
redisService.addStartedTask(promptId, comfyuiTask);
```

**作用：** 通过Retrofit调用ComfyUI API提交任务

#### ⑧ 监听WebSocket事件

**代码位置：** `ComfyuiMessageServiceImpl.handleMessage()`

```java
// 根据消息类型分发处理
if ("progress".equals(messageBase.getType())) {
    handleProgressMessage(messageBase);  // 进度消息
} else if ("executed".equals(messageBase.getType())) {
    handleExecutedMessage(messageBase);  // 完成消息
} else if ("execution_error".equals(messageBase.getType())) {
    handleExecutionErrorMessage(messageBase);  // 错误消息
}
```

**作用：** 后端作为WebSocket客户端，监听ComfyUI的任务执行事件

#### ⑨ 推送给前端

**代码位置：** `ComfyuiMessageServiceImpl`

```java
// 推送进度
wsNoticeService.sendToUser(task.getWsClientId(), JSON.toJSONString(data));

// 推送结果
HashMap<String, Object> temp = new HashMap<>();
temp.put("type", "imageResult");
temp.put("urls", urls);
wsNoticeService.sendToUser(task.getWsClientId(), JSON.toJSONString(temp));
```

**作用：** 通过STOMP协议将进度和结果推送给对应的前端用户

#### ⑩ 保存图片并扣除积分

**代码位置：** `ComfyuiMessageServiceImpl.handleExecutedMessage()`

```java
// 保存图片到数据库
userResultService.saveList(urls, task.getUserId());
// 释放信号量（在handleStatusMessage中）
semaphore.release();
```

**作用：** 
- 保存生成的图片URL到数据库，用户可查看历史记录
- 释放信号量，允许提交新任务
- 积分已在任务提交时冻结，执行成功后自动扣除

---

## 核心技术一：AI服务集成与工作流生成

### 1.1 技术概述

用户提交中文提示词后，系统需要：
1. 使用Ollama将中文翻译成英文（majicmixRealistic模型仅支持英文）
2. 使用Freemarker模板引擎动态生成ComfyUI工作流JSON
3. 通过Retrofit封装HTTP客户端调用AI服务

### 1.2 Ollama翻译实现

**代码位置：** `OllamaServiceImpl.java`

```java
@Override
public String translate(String prompt) {
    try {
        // 1. 构造Ollama消息对象
        OllamaMessage ollamaMessage = new OllamaMessage();
        ollamaMessage.setRole("user");
        ollamaMessage.setContent("帮我把以下内容翻译成英文:" + prompt);
        
        // 2. 构造请求对象，指定模型
        OllamaChatRequest body = new OllamaChatRequest();
        body.setModel("qwen2.5:0.5b");  // 使用通义千问0.5B版本（速度快）
        body.setMessages(List.of(ollamaMessage));
        
        // 3. 调用Ollama API
        Call<OllamaChatRespone> chat = ollamaApi.chat(body);
        Response<OllamaChatRespone> result = chat.execute();
        
        // 4. 返回翻译结果
        return result.body().getMessage().getContent();
    } catch (Exception e) {
        e.printStackTrace();
        return prompt;  // 翻译失败时降级：返回原文
    }
}
```

**技术要点：**
- 使用Retrofit封装HTTP客户端，简化API调用
- 降级策略：翻译失败时返回原文，保证业务不中断
- 模型选择：qwen2.5:0.5b参数量小，翻译速度快

### 1.3 Freemarker工作流生成

**代码位置：** `FreemarkerServiceImpl.java`

```java
@Override
public String renderText2Image(ComfyuiModel comfyuiModel) throws Exception {
    // 1. 加载模板文件
    Template template = configuration.getTemplate("t2i.ftlh");
    
    // 2. 准备数据模型
    Map<String, Object> data = new HashMap<>();
    data.put("config", comfyuiModel);  // 将参数对象传入模板
    
    // 3. 渲染模板，生成JSON
    StringWriter out = new StringWriter();
    template.process(data, out);  // 模板引擎替换占位符为实际值
    
    // 4. 返回ComfyUI工作流JSON字符串
    return out.toString();
}
```

**技术要点：**
- 使用Freemarker模板引擎动态生成JSON，避免硬编码
- 实现参数配置与流程解耦，便于维护和扩展
- 模板文件位置：`resources/templates/t2i.ftlh`

### 1.4 完整调用流程

**代码位置：** `Text2ImageServiceImpl.getComfyuiTask()`

```java
// 1. 翻译正向提示词：添加画质增强前缀 + Ollama翻译
comfyuiModel.setPropmt("(8k, best quality, masterpiece),(high detailed skin)," 
    + ollamaService.translate(text2ImageReqDto.getPropmt()));

// 2. 翻译负向提示词：Ollama翻译 + 添加负面词汇
comfyuiModel.setReverse(ollamaService.translate(text2ImageReqDto.getReverse()) 
    + ",bad face,naked,bad finger,bad arm,bad leg,bad eye");

// 3. 生成ComfyUI工作流JSON
String prompt = freemarkerService.renderText2Image(comfyuiModel);

// 4. 构造请求对象
ComfyuiRequestDto comfyuiRequestDto = new ComfyuiRequestDto(
    Constants.COMFYUI_CLIENT_ID, 
    JSON.parseObject(prompt)
);
```

**技术亮点：**
- 正向提示词自动添加画质增强前缀，提升生成质量
- 负向提示词自动添加常见瑕疵词汇，避免生成低质量图片
- 配置灵活，易于调整参数和工作流

---

## 核心技术二：Redis ZSet优先级队列

### 2.1 技术概述

使用Redis ZSet实现分布式优先级队列，支持：
- 任务入队（先进先出）
- 任务出队（原子操作）
- 任务插队（动态调整优先级）
- 任务取消（删除队列任务）

### 2.2 任务入队

**代码位置：** `RedisServiceImpl.addQueueTask()`

```java
@Override
public ComfyuiTask addQueueTask(ComfyuiTask comfyuiTask) {
    // 1. 使用Redis INCR命令获取分布式自增ID作为score
    Long score = stringRedisTemplate.opsForValue().increment(DISTRIBUTED_ID_KEY);
    
    // 2. 将任务ID作为member，score作为排序值，添加到ZSet
    stringRedisTemplate.opsForZSet().add(DISTRIBUTED_QUEUE_KEY, comfyuiTask.getId(), score);
    
    // 3. 获取任务在队列中的排名（rank从0开始）
    Long rank = stringRedisTemplate.opsForZSet().rank(DISTRIBUTED_QUEUE_KEY, comfyuiTask.getId());
    comfyuiTask.setIndex(rank != null ? rank + 1 : 1);  // +1转换为从1开始
    
    // 4. 将完整任务对象以JSON格式存储到Redis String
    stringRedisTemplate.opsForValue().set(TASK_KEY_PREFIX + comfyuiTask.getId(), JSON.toJSONString(comfyuiTask));
    
    return comfyuiTask;
}
```

**技术要点：**
- 使用分布式自增ID生成score，确保先提交的任务先执行
- ZSet自动按score从小到大排序，实现优先级队列
- 任务ID存储在ZSet，完整任务对象存储在String，避免ZSet存储大对象

### 2.3 任务出队

**代码位置：** `RedisServiceImpl.popQueueTask()`

```java
@Override
public ComfyuiTask popQueueTask() {
    Long size = stringRedisTemplate.opsForZSet().size(DISTRIBUTED_QUEUE_KEY);
    if (size > 0) {
        // 使用popMin原子操作：弹出并删除score最小的任务
        ZSetOperations.TypedTuple<String> task = stringRedisTemplate.opsForZSet().popMin(DISTRIBUTED_QUEUE_KEY);
        
        if (task != null && task.getValue() != null) {
            String taskId = task.getValue();
            // 获取完整任务对象
            String json = stringRedisTemplate.opsForValue().get(TASK_KEY_PREFIX + taskId);
            // 立即删除任务详情，释放内存
            stringRedisTemplate.delete(TASK_KEY_PREFIX + taskId);
            
            if (StrUtil.isNotEmpty(json)) {
                return JSON.parseObject(json, ComfyuiTask.class);
            }
        }
    }
    return null;
}
```

**技术要点：**
- 使用`popMin`原子操作，避免并发时多个实例取出同一任务
- 出队后立即删除任务详情，防止内存泄漏
- 返回score最小的任务，保证FIFO（先进先出）

### 2.4 任务插队

**代码位置：** `RedisServiceImpl.increasePriority()`

```java
@Override
public boolean increasePriority(String taskId, double increment) {
    // 减小分值可以提升优先级（ZSet按score从小到大排序）
    Double newScore = stringRedisTemplate.opsForZSet().incrementScore(DISTRIBUTED_QUEUE_KEY, taskId, -increment);
    return newScore != null;
}
```

**代码位置：** `Text2ImageServiceImpl.increasePriority()`（业务逻辑）

```java
// 1. 检查是否已经是第一名
if (currentRank != null && currentRank == 1) {
    throw new CustomException("当前任务已经是第一名，无需插队");
}

// 2. 先提升优先级（Redis操作）
boolean success = redisService.increasePriority(tempId, PRIORITY_INCREMENT);  // PRIORITY_INCREMENT = 10.0

// 3. 再扣除积分（数据库事务操作）
userFundRecordService.directDeduction(queueTask.getUserId(), PRIORITY_COST);  // PRIORITY_COST = 5
```

**技术要点：**
- 通过`incrementScore`减小score值来提升优先级，O(log N)时间复杂度
- 先操作Redis再扣积分，避免积分已扣但优先级未提升的情况
- 使用分布式锁防止并发插队同一任务

### 2.5 任务取消

**代码位置：** `RedisServiceImpl.removeQueueTask()`

```java
@Override
public boolean removeQueueTask(String taskId) {
    // 从ZSet队列中删除任务
    Long removed = stringRedisTemplate.opsForZSet().remove(DISTRIBUTED_QUEUE_KEY, taskId);
    // 删除任务详情
    Boolean deleted = stringRedisTemplate.delete(TASK_KEY_PREFIX + taskId);
    // 只有队列和详情都删除成功才返回true
    return removed != null && removed > 0 && deleted != null && deleted;
}
```

**代码位置：** `Text2ImageServiceImpl.cancelTask()`（业务逻辑）

```java
// 1. 验证任务是否存在、是否已开始、当前用户是否有权限操作
ComfyuiTask queueTask = validateTaskAndPermission(tempId, null, currentUserId);

// 2. 从Redis删除任务
boolean removed = redisService.removeQueueTask(tempId);

// 3. 归还冻结的积分
userFundRecordService.freezeReturn(queueTask.getUserId(), queueTask.getSize());
```

**技术要点：**
- 使用分布式锁防止并发取消同一任务
- 删除ZSet和String两处数据，确保数据一致性
- 取消成功后归还冻结积分，保证用户权益

---

## 核心技术三：定时任务调度与信号量控制

### 3.1 技术概述

使用Spring Task定时扫描Redis队列，取出任务提交给ComfyUI执行。结合Redisson实现：
- **分布式锁**：防止多实例重复执行定时任务
- **信号量控制**：限制ComfyUI并发任务数，防止GPU显存溢出

### 3.2 定时任务实现

**代码位置：** `RunTaskJob.task()`

```java
@Scheduled(cron = "*/1 * * * * ?")  // 每秒执行一次
public void task() {
    // 1. 获取分布式锁（集群环境下只有一个实例能执行）
    RLock lock = redissonClient.getLock(SPRING_TASK_LOCK_KEY);
    
    // 2. 尝试获取锁（非阻塞）
    if (lock.tryLock()) {
        try {
            // 3. 检查Redis队列是否有待处理任务
            if (redisService.hasQueueTask()) {
                // 4. 获取信号量（控制并发数）
                RSemaphore semaphore = redissonClient.getSemaphore(TASK_RUN_SEMAPHORE);
                
                // 5. 尝试获取信号量许可（非阻塞）
                if (semaphore.tryAcquire()) {
                    // 6. 从队列取出任务并提交给ComfyUI
                    sendTaskToComfyui();
                }
            }
        } finally {
            // 7. 释放分布式锁
            lock.unlock();
        }
    }
}
```

**技术要点：**
- 使用`@Scheduled`每秒触发一次，实时性高
- `tryLock`非阻塞获取锁，获取失败直接跳过本次执行
- `finally`确保锁一定会被释放，避免死锁

### 3.3 信号量控制并发

**代码位置：** `RunTaskJob.sendTaskToComfyui()`

```java
private void sendTaskToComfyui() {
    // 1. 从Redis队列弹出优先级最高的任务
    ComfyuiTask comfyuiTask = redisService.popQueueTask();
    if (comfyuiTask == null) {
        return;
    }
    
    // 2. 调用ComfyUI API提交任务
    Call<HashMap> hashMapCall = comfyuiApi.addQueueTask(comfyuiTask.getComfyuiRequestDto());
    try {
        Response<HashMap> response = hashMapCall.execute();
        if (response.isSuccessful()) {
            // 3. 提交成功，保存promptId到Redis
            String promptId = (String) response.body().get("prompt_id");
            comfyuiTask.setPromptId(promptId);
            redisService.addStartedTask(promptId, comfyuiTask);
        } else {
            // 4. 提交失败，释放信号量并归还积分
            RSemaphore semaphore = redissonClient.getSemaphore(TASK_RUN_SEMAPHORE);
            semaphore.release();  // 归还许可
            userFundRecordService.freezeReturn(comfyuiTask.getUserId(), comfyuiTask.getSize());
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

**信号量工作原理：**
1. 初始化时设置信号量许可数（如：3个，代表ComfyUI最多同时执行3个任务）
2. 定时任务`tryAcquire`获取一个许可，成功则提交任务
3. ComfyUI执行完成后，WebSocket接收到`status`消息，释放许可
4. 提交失败时，立即释放许可，避免资源浪费

**代码位置：** `ComfyuiMessageServiceImpl.handleStatusMessage()`

```java
// ComfyUI队列清空时释放信号量
if (queueRemaining == 0) {
    RSemaphore semaphore = redissonClient.getSemaphore(RunTaskJob.TASK_RUN_SEMAPHORE);
    semaphore.release();  // 释放一个许可
}
```

**技术要点：**
- 信号量限制并发数，防止GPU显存溢出
- 提交失败或执行完成都会释放信号量，确保资源不泄漏
- 非阻塞获取信号量，避免定时任务阻塞

---

## 核心技术四：WebSocket双向通信

### 4.1 技术概述

实现WebSocket双向通信架构：
- **作为客户端**：连接ComfyUI，接收任务执行进度（progress、executed、error事件）
- **作为服务端**：基于STOMP协议向前端推送消息

### 4.2 监听ComfyUI事件

**代码位置：** `ComfyuiMessageServiceImpl.handleMessage()`

```java
@Override
public void handleMessage(MessageBase messageBase) {
    // 根据消息类型分发处理
    if ("progress".equals(messageBase.getType())) {
        handleProgressMessage(messageBase);  // 处理进度消息
    } else if ("executed".equals(messageBase.getType())) {
        handleExecutedMessage(messageBase);  // 处理完成消息
    } else if ("execution_error".equals(messageBase.getType())) {
        handleExecutionErrorMessage(messageBase);  // 处理错误消息
    } else if ("status".equals(messageBase.getType())) {
        handleStatusMessage(messageBase);  // 处理状态消息
    }
}
```

### 4.3 推送进度给前端

**代码位置：** `ComfyuiMessageServiceImpl.handleProgressMessage()`

```java
private void handleProgressMessage(MessageBase messageBase) {
    // 1. 提取消息数据
    HashMap<String, Object> data = messageBase.getData();
    String promptId = data.get("prompt_id").toString();
    
    // 2. 根据promptId获取任务信息
    ComfyuiTask task = redisService.getStartedTask(promptId);
    if (task == null) {
        return;  // 任务不存在（可能已过期）
    }
    
    // 3. 设置消息类型
    data.put("type", "progress");
    
    // 4. 通过WebSocket推送给前端用户
    wsNoticeService.sendToUser(task.getWsClientId(), JSON.toJSONString(data));
}
```

**消息格式示例：**
```json
{
    "type": "progress",
    "data": {
        "value": 5,          // 当前步数
        "max": 20,           // 总步数
        "prompt_id": "594ac476-e599-47c1-a99f-bf8a384cfcdb"
    }
}
```

### 4.4 推送结果给前端

**代码位置：** `ComfyuiMessageServiceImpl.handleExecutedMessage()`

```java
private void handleExecutedMessage(MessageBase messageBase) {
    // 1. 提取图片信息
    HashMap<String, Object> data = messageBase.getData();
    HashMap<String, Object> output = (HashMap<String, Object>) data.get("output");
    List<HashMap<String, Object>> images = (List<HashMap<String, Object>>) output.get("images");
    
    // 2. 转换为可访问的URL列表
    List<String> urls = images.stream()
        .map(image -> String.format("http://192.168.100.129:8188/view?filename=%s&type=%s&subfolder=", 
            image.get("filename"), image.get("type")))
        .collect(Collectors.toList());
    
    // 3. 获取任务信息
    String promptId = data.get("prompt_id").toString();
    ComfyuiTask task = redisService.getStartedTask(promptId);
    
    // 4. 保存图片到数据库
    userResultService.saveList(urls, task.getUserId());
    
    // 5. 推送给前端
    HashMap<String, Object> temp = new HashMap<>();
    temp.put("type", "imageResult");
    temp.put("urls", urls);
    wsNoticeService.sendToUser(task.getWsClientId(), JSON.toJSONString(temp));
}
```

### 4.5 处理失败消息

**代码位置：** `ComfyuiMessageServiceImpl.handleExecutionErrorMessage()`

```java
private void handleExecutionErrorMessage(MessageBase messageBase) {
    // 1. 获取任务信息
    HashMap<String, Object> data = messageBase.getData();
    String promptId = data.get("prompt_id").toString();
    ComfyuiTask task = redisService.getStartedTask(promptId);
    
    // 2. 归还冻结的积分
    userFundRecordService.freezeReturn(task.getUserId(), task.getSize());
    
    // 3. 推送错误消息给前端
    data.put("type", "execution_error");
    wsNoticeService.sendToUser(task.getWsClientId(), JSON.toJSONString(data));
}
```

**技术要点：**
- 通过`promptId`关联ComfyUI任务和系统任务
- 使用`wsClientId`实现点对点推送，准确率100%
- 任务失败时归还积分，保证用户权益

---

## 核心技术五：乐观锁防并发冲突

### 5.1 技术概述

在积分系统中，使用MyBatis-Plus的`@Version`注解实现乐观锁机制，通过版本号比对防止并发更新冲突。结合`@Transactional`事务管理，保证积分冻结、扣除、归还等操作的原子性。

### 5.2 实体类设计

**代码位置：** `SgUserFund.java`

```java
@Getter
@Setter
@TableName("sg_user_fund")
public class SgUserFund implements Serializable {
    
    @TableId
    private Long id;
    
    // 可用积分账户
    private Long score;
    
    // 冻结积分账户
    private Long freezeScore;
    
    // 乐观锁版本号
    @Version
    private Long version;
    
    private Long userId;
    private LocalDateTime createdTime;
}
```

**设计要点：**
- **双账户设计**：`score`（可用积分）+ `freezeScore`（冻结积分）
- **乐观锁字段**：`@Version`注解标记版本号字段
- **工作原理**：每次更新时，MyBatis-Plus自动在SQL中添加`version`条件

### 5.3 乐观锁工作原理

**SQL自动改写示例：**

```sql
-- 开发者编写的代码
UPDATE sg_user_fund SET score = 100 WHERE id = 1;

-- MyBatis-Plus自动改写为
UPDATE sg_user_fund 
SET score = 100, version = version + 1 
WHERE id = 1 AND version = 5;

-- 如果version已被其他线程修改，WHERE条件不匹配，更新失败（返回0）
```

### 5.4 积分冻结实现

**代码位置：** `UserFundRecordServiceImpl.pointsFreeze()`

```java
@Override
public void pointsFreeze(Long userId, Integer money) {
    // 1. 获取用户积分账户
    SgUserFund sgUserFund = getUserSgUserFund(userId);
    
    // 2. 计算扣除积分后的余额
    long temp = sgUserFund.getScore() - money;
    
    // 3. 判断可用积分是否足够
    if(temp >= 0){
        // 减少可用积分
        sgUserFund.setScore(temp);
        // 增加冻结积分
        sgUserFund.setFreezeScore(sgUserFund.getFreezeScore() + money);
        
        // 4. 更新数据库（乐观锁自动生效）
        int updated = sgUserFundMapper.updateById(sgUserFund);
        
        // 5. 检查更新结果（乐观锁冲突检测）
        if (updated == 0) {
            throw new CustomException("积分更新失败，请重试");
        }
        
        // 6. 记录积分变动日志
        saveLog(0, -money, sgUserFund.getId());  // 可用积分减少
        saveLog(1, money, sgUserFund.getId());    // 冻结积分增加
    } else {
        throw new CustomException("积分账户余额不足");
    }
}
```

**并发场景示例：**

假设用户A当前积分为100，两个请求同时提交任务（每个任务消耗50积分）：

| 时间 | 线程1 | 线程2 | 数据库状态 |
|------|-------|-------|------------|
| T1 | 查询：score=100, version=1 | 查询：score=100, version=1 | score=100, version=1 |
| T2 | 计算：100-50=50 | 计算：100-50=50 | score=100, version=1 |
| T3 | 更新：WHERE version=1 ✅ | 等待... | score=50, version=2 |
| T4 | 提交成功 | 更新：WHERE version=1 ❌ | score=50, version=2 |
| T5 | - | 抛出异常：更新失败 | score=50, version=2 |

**结果：** 线程2更新失败，避免了超扣积分的问题

### 5.5 事务保证原子性

**代码位置：** `UserFundRecordServiceImpl`类级别

```java
@Service
@Transactional  // 类级别事务，所有public方法都有事务保护
@Slf4j
public class UserFundRecordServiceImpl extends ServiceImpl<...> {
    
    @Override
    public void pointsDeduction(Long userId, Integer money) {
        // 获取用户账户
        SgUserFund userFund = getUserSgUserFund(userId);
        // 获取系统总账户（userId=0）
        SgUserFund allFund = getUserSgUserFund(0);
        
        // 操作1：从用户冻结账户扣除
        userFund.setFreezeScore(userFund.getFreezeScore() - money);
        saveLog(1, -money, userFund.getId());
        int updated1 = sgUserFundMapper.updateById(userFund);
        if (updated1 == 0) {
            throw new CustomException("积分更新失败，请重试");  // 抛异常会回滚
        }
        
        // 操作2：将积分转入系统总账户
        allFund.setScore(allFund.getScore() + money);
        saveLog(0, money, allFund.getId());
        int updated2 = sgUserFundMapper.updateById(allFund);
        if (updated2 == 0) {
            throw new CustomException("积分更新失败，请重试");  // 抛异常会回滚
        }
    }
}
```

**事务作用：**
- 操作1成功、操作2失败 → 整体回滚，数据一致性不被破坏
- 任何异常抛出 → 所有数据库操作回滚

### 5.6 技术亮点总结

1. ✅ **乐观锁防并发冲突**：版本号机制，不加锁也能保证安全
2. ✅ **事务保证原子性**：多步操作要么全成功，要么全失败
3. ✅ **双账户设计**：冻结/可用分离，任务失败可归还
4. ✅ **完整流水日志**：每次变动都记录，便于审计

---

## 核心技术六：Redis分布式锁与Lua脚本

### 6.1 技术概述

基于Redis SETNX命令手动实现轻量级分布式锁，用于任务取消和插队场景的并发控制。使用Lua脚本实现原子化解锁，通过get+del一体化操作防止误删其他线程的锁。

### 6.2 分布式锁实现

**代码位置：** `Text2ImageServiceImpl.tryLock()`

```java
private boolean tryLock(String lockKey, String lockValue) {
    // 使用Redis的SETNX命令（setIfAbsent）实现分布式锁
    // NX: Not eXist，只有key不存在时才设置
    // EX: 设置过期时间，防止死锁
    Boolean result = stringRedisTemplate.opsForValue()
            .setIfAbsent(lockKey, lockValue, LOCK_TIMEOUT, TimeUnit.SECONDS);
    
    // 返回是否成功获取锁
    return Boolean.TRUE.equals(result);
}
```

**等价Redis命令：**
```bash
SET lock:task:xxx <uuid> NX EX 30
```

**参数说明：**
- `lockKey`：`"lock:task:" + taskId`，每个任务独立的锁
- `lockValue`：`UUID.randomUUID().toString()`，唯一标识锁的持有者
- `LOCK_TIMEOUT`：30秒过期时间，防止持锁进程崩溃导致死锁

### 6.3 Lua脚本原子解锁

**代码位置：** `Text2ImageServiceImpl.unlock()`

```java
private void unlock(String lockKey, String lockValue) {
    // Lua脚本：先判断锁是否是自己的，是才删除
    String luaScript = "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                       "return redis.call('del', KEYS[1]) " +
                       "else return 0 end";
    
    // 创建Redis脚本对象
    DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>(luaScript, Long.class);
    
    // 执行Lua脚本
    stringRedisTemplate.execute(
        redisScript, 
        Collections.singletonList(lockKey),  // KEYS[1]
        lockValue                             // ARGV[1]
    );
}
```

**Lua脚本解析：**

```lua
-- 获取锁的值
local lockValue = redis.call('get', KEYS[1])

-- 判断是否是当前线程的锁
if lockValue == ARGV[1] then
    -- 是自己的锁，才删除
    return redis.call('del', KEYS[1])
else
    -- 不是自己的锁，不删除
    return 0
end
```

### 6.4 为什么需要Lua脚本？

**❌ 不使用Lua脚本的问题：**

```java
// 方案一：先get后del（错误示例）
String value = redis.get(lockKey);
if (lockValue.equals(value)) {
    redis.del(lockKey);  // 可能删除了其他线程的锁！
}
```

**并发问题示例：**

| 时间 | 线程A（持有锁） | 线程B |
|------|----------------|-------|
| T1 | GET lock → A的UUID ✅ | - |
| T2 | 锁过期（30秒到期） | - |
| T3 | - | SETNX lock → B的UUID ✅ |
| T4 | DEL lock ❌（删除了B的锁！） | - |
| T5 | - | 继续执行（误以为持有锁）❌ |

**✅ 使用Lua脚本的优势：**
1. **原子性**：Redis保证Lua脚本执行期间不会插入其他命令
2. **防误删**：只有lockValue匹配才删除，避免删除别人的锁
3. **高性能**：一次网络请求完成判断+删除

### 6.5 完整使用示例

**代码位置：** `Text2ImageServiceImpl.cancelTask()`

```java
@Override
public void cancelTask(String tempId) {
    Long currentUserId = UserUtils.getUser().getId();
    
    // 1. 构造分布式锁的key和value
    String lockKey = LOCK_KEY_PREFIX + tempId;  // "lock:task:xxx"
    String lockValue = UUID.randomUUID().toString();
    
    // 2. 尝试获取分布式锁
    if (!tryLock(lockKey, lockValue)) {
        throw new CustomException("操作过于频繁，请稍后再试");
    }
    
    try {
        // 3. 验证任务权限
        ComfyuiTask queueTask = validateTaskAndPermission(tempId, null, currentUserId);
        
        // 4. 删除Redis中的任务
        boolean removed = redisService.removeQueueTask(tempId);
        if (!removed) {
            throw new CustomException("任务取消失败");
        }
        
        // 5. 归还冻结的积分
        userFundRecordService.freezeReturn(queueTask.getUserId(), queueTask.getSize());
        
        log.info("用户{}成功取消任务{}", currentUserId, tempId);
    } catch (Exception e) {
        throw e;
    } finally {
        // 6. 释放分布式锁（使用Lua脚本）
        try {
            unlock(lockKey, lockValue);
        } catch (Exception e) {
            log.error("释放锁失败: lockKey={}", lockKey, e);
        }
    }
}
```

### 6.6 应用场景

**场景1：取消任务**
- 防止用户并发取消同一任务
- 锁粒度：每个任务独立的锁（`lock:task:{taskId}`）

**场景2：任务插队**
- 防止用户并发插队同一任务
- 锁粒度：每个任务独立的锁（`lock:task:{taskId}`）

### 6.7 技术对比

| 特性 | Redis轻量级锁（本项目） | Redisson锁（定时任务） |
|------|------------------------|----------------------|
| **实现方式** | 手动SETNX + Lua脚本 | Redisson封装 |
| **续期机制** | ❌ 固定过期时间 | ✅ 看门狗自动续期 |
| **适用场景** | 短时操作（秒级） | 长时操作（分钟级） |
| **锁粒度** | 细粒度（每个任务） | 粗粒度（全局调度） |
| **复杂度** | 低（手动实现） | 高（依赖Redisson） |

### 6.8 技术亮点总结

1. ✅ **手动实现分布式锁**：掌握底层原理，不依赖框架
2. ✅ **Lua脚本原子解锁**：防止误删锁，保证并发安全
3. ✅ **防死锁设计**：固定过期时间 + finally必释放
4. ✅ **细粒度锁设计**：每个任务独立锁，减少锁竞争

---

## 文档总结

本文档详细讲解了AI智绘云平台的6大核心技术：

1. ✅ **AI服务集成与工作流生成**：Retrofit + Ollama翻译 + Freemarker模板
2. ✅ **Redis ZSet优先级队列**：分布式队列 + 动态插队 + 任务取消
3. ✅ **定时任务调度与信号量控制**：Spring Task + Redisson分布式锁 + 信号量
4. ✅ **WebSocket双向通信**：客户端监听ComfyUI + 服务端推送前端
5. ✅ **乐观锁防并发冲突**：@Version版本号 + @Transactional事务
6. ✅ **Redis分布式锁与Lua脚本**：SETNX实现 + Lua原子解锁

每项技术都结合实际代码详细剖析，可作为面试准备和技术回顾的参考资料。
