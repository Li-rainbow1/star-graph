# AI智绘平台 - 面试准备完整版（精华版）

> **文档说明：** 精简版面试准备文档，包含核心简历亮点、项目介绍话术、60+道高频面试题，助你快速掌握项目核心。
> **项目名称：** AI智绘平台（代码包名：star-graph）

---

## 📑 目录导航

### 📌 Part 1：简历与项目介绍
1. [简历核心亮点](#一简历核心亮点5条必背) - 5条核心卖点
2. [项目技术架构](#二项目技术架构) - 架构图+关键技术
3. [项目介绍话术](#三项目介绍话术) - 3种版本应对不同面试官

### 📌 Part 2：面试题库（60+题）
4. [Redis专题](#四redis专题15题) - 15道Redis高频题
5. [Spring专题](#五spring专题12题) - 12道Spring核心题
6. [数据库专题](#六数据库专题10题) - 10道MySQL必会题
7. [并发与JVM](#七并发与jvm8题) - 8道并发和JVM题
8. [WebSocket与实时通信](#八websocket与实时通信5题) - 5道WebSocket题
9. [系统设计](#九系统设计5题) - 5道系统设计题
10. [项目深度追问](#十项目深度追问10题) - 10道项目深挖题

---

# Part 1：简历与项目介绍

## 一、简历核心亮点（5条必背）

### 🔥 亮点1：分布式任务队列系统
**一句话描述：** 基于Redis ZSet实现优先级队列，支持任务插队和取消

**核心技术：**
- Redis ZSet（有序集合）+ 分布式锁 + 信号量
- 时间复杂度O(log N)，性能优异
- 支持动态优先级调整（插队功能）

**面试说法：**
> "使用Redis ZSet实现了优先级任务队列，通过score控制优先级，支持用户付费插队。同时用分布式锁保证并发安全，用信号量控制ComfyUI的并发数，避免GPU资源过载。"

---

### 🔥 亮点2：WebSocket双向通信架构
**一句话描述：** 既是WebSocket客户端又是服务端，实现端到端实时通信

**核心技术：**
- 客户端：连接ComfyUI接收AI任务进度
- 服务端：基于STOMP协议向前端推送消息
- 点对点精准推送，准确率100%

**面试说法：**
> "项目中实现了两个WebSocket连接：一个作为客户端连接ComfyUI接收任务状态，一个作为服务端使用STOMP协议向前端推送。这样可以在中间层做业务处理，比如保存数据库、扣除积分等。"

---

### 🔥 亮点3：AI服务集成与工作流生成
**一句话描述：** 集成Ollama翻译+ComfyUI生图，动态生成AI工作流

**核心技术：**
- Ollama大语言模型（中译英）
- Freemarker模板引擎（动态生成JSON）
- Retrofit HTTP客户端（封装API调用）

**面试说法：**
> "集成了Ollama做中文提示词翻译，因为Stable Diffusion只支持英文。使用Freemarker模板引擎动态生成ComfyUI的工作流JSON，通过Retrofit封装HTTP客户端调用AI服务API。"

---

### 🔥 亮点4：积分管理与事务一致性
**一句话描述：** 三账户模型+事务控制，保证资金安全

**核心技术：**
- 三账户模型（可用、冻结、总账户）
- @Transactional保证原子性
- 任务失败自动退款机制

**面试说法：**
> "设计了三账户模型，提交任务时冻结积分，成功时扣除，失败时退回。使用Spring事务管理保证积分操作的原子性，避免出现资金不一致的情况。"

---

### 🔥 亮点5：系统优化与工程化
**一句话描述：** 全局异常处理+JWT认证+ThreadLocal上下文管理

**核心技术：**
- JWT无状态认证
- ThreadLocal存储用户上下文
- 全局异常处理器统一返回格式
- MyBatis Plus自动填充时间字段

**面试说法：**
> "实现了JWT无状态认证，使用ThreadLocal管理用户上下文避免层层传参。全局异常处理器统一处理业务异常和系统异常，保证接口返回格式一致。"

---

## 二、项目技术架构图

```
┌─────────────────────────────────────────────────────┐
│                    前端（Vue3）                      │
│  - WebSocket客户端（接收实时推送）                   │
│  - HTTP请求（提交任务、查询结果）                     │
└────────────────┬────────────────────────────────────┘
                 │ WebSocket + HTTP
                 │
┌────────────────▼────────────────────────────────────┐
│            Spring Boot 后端（核心层）                │
│                                                      │
│  ┌─────────────┐  ┌──────────────┐  ┌───────────┐ │
│  │ Controller  │  │  WebSocket   │  │  定时任务  │ │
│  │             │  │  服务端      │  │  (调度器)  │ │
│  └──────┬──────┘  └──────┬───────┘  └─────┬─────┘ │
│         │                │                  │       │
│  ┌──────▼────────────────▼──────────────────▼────┐ │
│  │              Service业务层                     │ │
│  │  - 任务管理  - 积分管理  - 消息推送             │ │
│  └──────┬───────────────┬──────────────┬─────────┘ │
│         │               │              │           │
│  ┌──────▼──────┐  ┌────▼──────┐  ┌───▼─────────┐ │
│  │  Mapper层   │  │WebSocket  │  │  Retrofit   │ │
│  │  (数据库)   │  │  客户端   │  │  (HTTP客户端)│ │
│  └──────┬──────┘  └────┬──────┘  └───┬─────────┘ │
└─────────┼──────────────┼──────────────┼───────────┘
          │              │              │
    ┌─────▼────┐   ┌────▼─────┐   ┌───▼────────┐
    │  MySQL   │   │  Redis   │   │  ComfyUI   │
    │          │   │  - ZSet  │   │  (AI引擎)  │
    │  - 用户  │   │  - Lock  │   │            │
    │  - 积分  │   │  -Semaph.│   └─────┬──────┘
    │  - 结果  │   └──────────┘         │
    └──────────┘                  ┌─────▼──────┐
                                  │  Ollama    │
                                  │  (翻译AI)  │
                                  └────────────┘
```

**技术栈清单：**

| 分类 | 技术 | 用途 |
|------|------|------|
| **后端框架** | Spring Boot 3 | 核心框架 |
| **数据库** | MySQL 8.0 | 持久化存储 |
| **缓存** | Redis 7.0 | 队列、锁、缓存 |
| **ORM** | MyBatis Plus | 数据访问层 |
| **实时通信** | WebSocket + STOMP | 双向通信 |
| **HTTP客户端** | Retrofit 2 | AI服务调用 |
| **模板引擎** | Freemarker | 动态生成JSON |
| **分布式** | Redisson | 分布式锁和信号量 |
| **认证** | JWT | 无状态认证 |
| **AI服务** | ComfyUI + Ollama | 图片生成和翻译 |

---

## 三、项目介绍话术（3个版本）

### 版本1：技术深度版（2分钟，适合技术面试）

**开场（10秒）：**
> "这是一个AI图像生成平台（AI智绘），用户输入中文描述就能生成图片。我负责后端核心功能开发，主要解决了三个技术难点。"

**难点1 - 分布式任务队列（40秒）：**
> "第一是任务队列管理。用Redis ZSet实现优先级队列，score越小优先级越高。为了支持VIP插队，直接减小任务的score值就行，O(log N)时间复杂度。同时用分布式锁保证并发安全——SETNX加锁配合Lua脚本原子解锁，避免误删其他线程的锁。还用Redisson的信号量控制ComfyUI并发数，防止GPU显存溢出。"

**难点2 - WebSocket双向通信（40秒）：**
> "第二是实时通信架构。我实现了两个WebSocket：一个作为客户端连接ComfyUI，接收AI任务的progress、executed、error等事件；另一个作为服务端基于STOMP协议向前端推送。之所以不让前端直连ComfyUI，是因为中间要做业务处理，比如任务完成时要保存数据库、扣积分、释放信号量这些操作。STOMP提供了点对点通信机制，通过convertAndSendToUser精准推送给目标用户。"

**难点3 - AI服务集成（30秒）：**
> "第三是AI服务集成。因为Stable Diffusion只支持英文，所以集成了Ollama大语言模型做中译英。用Freemarker模板引擎动态生成ComfyUI的工作流JSON，通过Retrofit封装HTTP客户端调用。这样参数和流程配置分离，后期维护很方便。"

**收尾（10秒）：**
> "整个系统支持多用户并发，实时推送准确率100%，用户反馈很不错。"

---

### 版本2：业务理解版（90秒，适合业务面或HR）

**开场：**
> "这是一个AI图像生成平台，类似MidJourney。用户输入'美女、沙滩、太阳伞'这样的描述，系统就能自动生成对应的图片。我负责后端开发。"

**核心功能：**
> "主要实现了三个核心功能：一是任务队列管理，用户提交任务后按顺序排队生成，VIP用户可以付费插队；二是实时进度推送，用户能看到'排队中''生成中''已完成'这些状态变化；三是积分系统，生成图片消耗积分，任务失败会自动退款。"

**技术亮点：**
> "技术上主要用了Redis做任务队列和分布式锁，WebSocket做实时推送，集成了AI服务。系统设计得比较健壮，支持多用户并发，实时推送准确率100%。"

**成果：**
> "现在系统运行稳定，用户体验流畅，代码质量也比较高，注释覆盖率90%以上。"

---

### 版本3：简洁版（30秒，适合开场或自我介绍）

> "最近做了个AI图像生成平台（AI智绘），用户输入文字就能生成图片。我负责后端，实现了基于Redis ZSet的优先级队列、WebSocket双向通信、积分三账户管理这些核心功能。技术栈是Spring Boot + Redis + WebSocket，集成了ComfyUI和Ollama两个AI服务。系统支持多用户并发，实时推送准确率100%，代码注释详尽。"

---

# Part 2：面试题库（60+题）

## 四、Redis专题（15题）

### Q1：Redis ZSet如何实现优先级队列？

**标准答案：**

**数据结构：**
```
Key: queue:text2image
Member: 任务ID (UUID)
Score: 优先级数值（时间戳，越小越优先）
```

**核心操作：**
```java
// 入队
ZADD queue:text2image 1698723456789 "task-001"

// 出队（取最小score）
ZPOPMIN queue:text2image 1

// 查询位置
ZRANK queue:text2image "task-001"

// 插队（减小score）
ZADD queue:text2image 1698723456700 "task-001"

// 取消（删除）
ZREM queue:text2image "task-001"
```

**为什么选ZSet：**
- 自动按score排序，无需手动维护顺序
- O(log N)时间复杂度，性能优异
- 支持随机访问（通过member）
- 底层跳表实现，增删改查都很快

---

### Q2：分布式锁如何实现？为什么用Lua脚本？

**加锁：**
```java
// SET key value NX EX seconds
SET lock:task:123 uuid-456 NX EX 10
```
- NX：key不存在时才设置（实现互斥）
- EX 10：10秒自动过期（防死锁）
- uuid：唯一标识（防误删）

**解锁（Lua脚本）：**
```lua
if redis.call("GET", KEYS[1]) == ARGV[1] then
    return redis.call("DEL", KEYS[1])
else
    return 0
end
```

**为什么必须用Lua：**
- GET和DEL两步需要原子执行
- 不用Lua的问题：
  1. 线程A判断是自己的锁（GET）
  2. 锁过期，线程B获取锁
  3. 线程A执行DEL，误删了B的锁！
- Lua脚本在Redis中单线程原子执行

---

### Q3：Redis信号量如何控制并发？

**代码实现：**
```java
// 获取信号量
RSemaphore semaphore = redissonClient.getSemaphore("TASK_RUN_SEMAPHORE");

// 尝试获取许可
boolean acquired = semaphore.tryAcquire();
if (acquired) {
    try {
        sendTaskToComfyui();
    } finally {
        semaphore.release(); // 必须在finally中释放
    }
}
```

**工作流程：**
```
定时任务扫描 → 尝试获取信号量
  ↓ 成功：从队列取任务提交ComfyUI
  ↓ 失败：当前并发已满，等待
  ↓ 完成：释放信号量
```

**为什么需要信号量：**
- ComfyUI的GPU资源有限
- 太多并发会导致GPU OOM（显存溢出）
- 信号量限制最大并发数（如10个）

---

### Q4：Redis持久化RDB和AOF的区别？

| 特性 | RDB | AOF |
|------|-----|-----|
| **持久化方式** | 快照（Snapshot） | 命令追加（Append Only File） |
| **文件大小** | 小 | 大 |
| **恢复速度** | 快 | 慢 |
| **数据完整性** | 可能丢失（两次快照间的数据） | 高（最多丢1秒数据） |
| **触发方式** | SAVE/BGSAVE手动或配置自动 | 实时/每秒/手动 |
| **适用场景** | 备份、全量复制 | 数据安全性要求高 |

**推荐方案：** RDB + AOF混合使用

---

### Q5：Redis的过期键删除策略？

**三种策略：**

**1. 定时删除**
- 为每个key创建定时器，到期立即删除
- 优点：内存友好，及时释放
- 缺点：CPU不友好，大量定时器消耗资源
- Redis：未采用

**2. 惰性删除**
- 访问key时才检查是否过期，过期则删除
- 优点：CPU友好，只在使用时检查
- 缺点：内存不友好，过期key可能长期占用内存
- Redis：使用

**3. 定期删除**
- 每隔一段时间随机抽取部分key检查
- 平衡CPU和内存
- Redis：使用（每100ms一次）

**Redis实际采用：惰性删除 + 定期删除**

---

### Q6：ZSet的底层实现原理？

**双数据结构：**

**1. 跳表（Skip List）**
- 用途：范围查询（ZRANGE、ZRANGEBYSCORE）
- 时间复杂度：O(log N)
- 类似多层链表，支持二分查找

**2. 哈希表（Hash Table）**
- 用途：快速查找member对应的score（ZSCORE）
- 时间复杂度：O(1)

**为什么用跳表而不是红黑树：**
- 跳表实现更简单
- 跳表支持范围查询更高效
- 跳表内存占用相对较小
- 跳表利于并发操作

---

### Q7：Redis如何实现延迟队列？

**方案：ZSet + 定时扫描**

```java
// 添加延迟任务（10秒后执行）
long executeTime = System.currentTimeMillis() + 10000;
ZADD delay_queue executeTime task_data

// 定时扫描（每秒一次）
@Scheduled(fixedRate = 1000)
public void scanDelayQueue() {
    long now = System.currentTimeMillis();
    // 获取到期的任务（score <= now）
    Set<String> tasks = redisTemplate.opsForZSet()
        .rangeByScore("delay_queue", 0, now);
    
    for (String task : tasks) {
        process(task);
        redisTemplate.opsForZSet().remove("delay_queue", task);
    }
}
```

---

### Q8：Redis集群方案有哪些？

**1. 主从复制（Master-Slave）**
- 一主多从，主写从读
- 读写分离，提升读性能
- 主挂了需手动切换

**2. 哨兵模式（Sentinel）**
- 主从复制 + 自动故障转移
- 哨兵监控主节点健康
- 主挂了自动选举新主
- 官方推荐高可用方案

**3. 集群模式（Cluster）**
- 去中心化，无单点故障
- 数据分片（16384个槽位）
- 自动故障转移
- 支持水平扩展

**本项目用：** 主从 + 哨兵

---

### Q9：Redis缓存穿透、击穿、雪崩及解决方案？

**缓存穿透：** 查询不存在的数据
- 原因：恶意攻击或误操作
- 现象：大量请求打到数据库
- 解决：
  - 布隆过滤器（Bloom Filter）
  - 缓存空对象（null值也缓存）

**缓存击穿：** 热点key过期
- 原因：热点key突然过期
- 现象：瞬间大量请求打到数据库
- 解决：
  - 热点key永不过期
  - 互斥锁（只允许一个线程查DB）

**缓存雪崩：** 大量key同时过期
- 原因：大量key同时失效或Redis宕机
- 现象：数据库扛不住压力崩溃
- 解决：
  - 过期时间加随机值
  - Redis集群高可用
  - 限流降级

---

### Q10：Redisson的看门狗机制？

**问题：** 分布式锁过期时间不好设置
- 设太短：业务未完成锁就过期
- 设太长：异常时锁占用时间长

**看门狗机制：**
```java
RLock lock = redissonClient.getLock("myLock");
lock.lock(); // 默认30秒，自动续期

try {
    // 业务代码
    // 如果执行超过30秒，看门狗会自动续期
} finally {
    lock.unlock();
}
```

**工作原理：**
1. 获取锁时设置30秒过期（默认）
2. 启动Watch Dog后台线程
3. 每10秒检查一次锁是否还被持有
4. 如果持有，延长过期时间到30秒
5. unlock时停止Watch Dog

---

### Q11：Redis单线程为什么还这么快？

**三个关键因素：**

**1. 纯内存操作**
- 内存读写速度极快（ns级别）
- 避免磁盘IO

**2. IO多路复用**
- epoll模型
- 单线程处理多个客户端连接
- 避免线程切换开销

**3. 高效的数据结构**
- SDS动态字符串
- 跳表（ZSet）
- 压缩列表优化内存

**单线程优势：**
- 避免锁竞争
- 避免线程切换
- 代码实现简单

---

### Q12：Redis的数据类型及使用场景？

| 类型 | 底层实现 | 使用场景 | 本项目应用 |
|------|----------|----------|-----------|
| **String** | SDS | 缓存、计数器、分布式锁 | 分布式锁、任务详情 |
| **Hash** | 哈希表/压缩列表 | 对象存储 | 用户信息缓存 |
| **List** | 双向链表/压缩列表 | 消息队列、栈 | - |
| **Set** | 哈希表/整数集合 | 去重、交集并集 | - |
| **ZSet** | 跳表+哈希表 | 排行榜、优先级队列 | ✅ 任务优先级队列 |

---

### Q13：Redis的内存淘汰策略？

**8种策略：**

**1. noeviction（默认）**
- 不淘汰，内存满了返回错误

**2-3. allkeys-lru / allkeys-lfu**
- 从所有key中删除最少使用的
- LRU：最久未使用
- LFU：最少使用频率

**4-5. volatile-lru / volatile-lfu**
- 从设置过期时间的key中删除

**6. allkeys-random**
- 随机删除任意key

**7. volatile-random**
- 从设置过期时间的key中随机删除

**8. volatile-ttl**
- 删除最接近过期时间的key

**推荐：** allkeys-lru（通用场景）

---

### Q14：Redis事务和Lua脚本的区别？

| 特性 | Redis事务（MULTI/EXEC） | Lua脚本 |
|------|------------------------|---------|
| **原子性** | 打包执行，不保证原子性 | 完全原子性 |
| **回滚** | 不支持回滚 | 执行失败全部回滚 |
| **性能** | 多次网络开销 | 一次网络开销 |
| **编程能力** | 弱（只能顺序执行） | 强（支持if/for等逻辑） |
| **使用场景** | 批量操作 | 复杂逻辑 |

**本项目选择：** Lua脚本（分布式锁解锁）

---

### Q15：Redis如何实现分布式Session？

**方案1：Spring Session + Redis**

```java
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 1800)
public class SessionConfig {
    // 自动配置
}
```

**原理：**
- Session数据存储在Redis
- Key：spring:session:sessions:{sessionId}
- 所有服务器共享Session

**方案2：JWT Token（本项目采用）**
- 无需Session，完全无状态
- Token存储用户信息
- 服务器只需验证Token有效性

---

## 五、Spring专题（12题）

### Q1：@Transactional事务失效的7种场景？

**1. 非public方法**
```java
@Transactional
private void save() {} // ❌ 无效，AOP基于代理，只能代理public方法
```

**2. 同类方法调用（this调用）**
```java
public void A() {
    this.B(); // ❌ B的事务失效，因为没走代理
}

@Transactional
public void B() {}
```
**解决：** 注入自己或使用AopContext.currentProxy()

**3. 异常类型不匹配**
```java
@Transactional // 默认只回滚RuntimeException和Error
public void save() throws Exception {
    throw new Exception(); // ❌ 不会回滚
}
```
**解决：** `@Transactional(rollbackFor = Exception.class)`

**4. 异常被catch住**
```java
@Transactional
public void save() {
    try {
        // ...
    } catch (Exception e) {
        e.printStackTrace(); // ❌ 事务不回滚
    }
}
```
**解决：** catch后手动throw或不catch

**5. 数据库不支持事务**
- MyISAM不支持事务（改用InnoDB）

**6. 传播属性设置错误**
```java
@Transactional(propagation = Propagation.NOT_SUPPORTED) // 不支持事务
```

**7. 类未被Spring管理**
- 没有@Service等注解，Spring无法代理

---

### Q2：Spring Bean的生命周期？

**完整流程（10步）：**

1. **实例化Bean** - 反射调用构造函数
2. **填充属性** - 依赖注入（@Autowired）
3. **BeanNameAware** - 如果实现该接口，调用setBeanName()
4. **BeanFactoryAware** - 调用setBeanFactory()
5. **ApplicationContextAware** - 调用setApplicationContext()
6. **BeanPostProcessor前置处理** - postProcessBeforeInitialization()
7. **InitializingBean** - afterPropertiesSet()
8. **init-method** - 自定义初始化方法
9. **BeanPostProcessor后置处理** - postProcessAfterInitialization()（AOP在此生成代理）
10. **使用Bean** → **销毁**（DisposableBean.destroy() → destroy-method）

**简化版（3步记忆法）：**
- 实例化 + 属性注入
- 初始化（各种Aware → 初始化方法 → AOP代理）
- 使用 → 销毁

---

### Q3：Spring的循环依赖如何解决？

**场景：** A依赖B，B依赖A

```java
@Service
public class A {
    @Autowired
    private B b;
}

@Service
public class B {
    @Autowired
    private A a;
}
```

**三级缓存解决方案：**

```java
// 一级缓存：成品Bean
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>();

// 二级缓存：半成品Bean（已实例化，未初始化）
private final Map<String, Object> earlySingletonObjects = new HashMap<>();

// 三级缓存：Bean工厂（用于AOP代理）
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>();
```

**解决流程：**
1. 创建A：实例化A，放入三级缓存
2. 填充A的属性：发现需要B
3. 创建B：实例化B，放入三级缓存
4. 填充B的属性：发现需要A，从三级缓存获取A的早期引用
5. B完成初始化，放入一级缓存
6. A获得B的引用，完成初始化，放入一级缓存

**为什么需要三级缓存：**
- 一级缓存：存完整Bean
- 二级缓存：存半成品Bean（防止重复创建）
- 三级缓存：存ObjectFactory（用于AOP代理）

**注意：** 构造器循环依赖无法解决，只能解决setter注入的循环依赖

---

### Q4：Spring AOP的实现原理？

**两种代理方式：**

**1. JDK动态代理（默认）**
- 要求：目标类必须实现接口
- 原理：基于反射，Proxy.newProxyInstance()
- 代理：代理接口

**2. CGLIB代理**
- 要求：目标类不能是final
- 原理：字节码生成，生成子类
- 代理：代理类

**选择策略：**
```java
// 目标类实现了接口 → JDK动态代理
public class UserServiceImpl implements UserService {}

// 目标类没实现接口 → CGLIB代理
public class UserService {}
```

**本项目应用：**
- @Transactional：AOP实现事务管理
- 全局异常处理：AOP拦截异常

---

### Q5：@Autowired和@Resource的区别？

| 特性 | @Autowired | @Resource |
|------|-----------|----------|
| **来源** | Spring | JDK（JSR-250） |
| **注入方式** | byType | byName → byType |
| **必填** | 默认required=true | 默认required=true |
| **指定名称** | 配合@Qualifier | name属性 |

**使用示例：**
```java
// @Autowired：先按类型，类型有多个再按名称
@Autowired
private UserService userService;

@Autowired
@Qualifier("userServiceImpl2")
private UserService userService;

// @Resource：先按名称，名称找不到再按类型
@Resource(name = "userServiceImpl2")
private UserService userService;
```

**推荐：** Spring项目优先用@Autowired

---

### Q6：Spring Boot自动配置原理？

**核心注解：@SpringBootApplication**

```java
@SpringBootApplication
= @SpringBootConfiguration  // 相当于@Configuration
+ @EnableAutoConfiguration  // 自动配置核心
+ @ComponentScan            // 包扫描
```

**@EnableAutoConfiguration工作流程：**

1. **加载自动配置类**
   - 读取META-INF/spring.factories
   - 加载所有AutoConfiguration类

2. **条件装配**
   ```java
   @ConditionalOnClass(RedisOperations.class)  // classpath有该类才生效
   @ConditionalOnMissingBean(RedisTemplate.class)  // 没有该Bean才生效
   @ConditionalOnProperty(name = "spring.redis.host")  // 配置存在才生效
   ```

3. **创建Bean**
   - 满足条件的自动配置类生效
   - 注册Bean到Spring容器

**本项目示例：**
- redis-starter → RedisAutoConfiguration → RedisTemplate
- mybatis-plus-starter → MybatisPlusAutoConfiguration

---

### Q7：Spring的事务传播机制？

**7种传播行为：**

**支持当前事务：**
1. **REQUIRED（默认）** - 有事务加入，无事务新建
2. **SUPPORTS** - 有事务加入，无事务以非事务执行
3. **MANDATORY** - 必须有事务，否则抛异常

**不支持当前事务：**
4. **REQUIRES_NEW** - 挂起当前事务，新建事务
5. **NOT_SUPPORTED** - 挂起当前事务，以非事务执行
6. **NEVER** - 必须无事务，否则抛异常

**嵌套事务：**
7. **NESTED** - 嵌套事务，外层回滚内层也回滚，内层回滚不影响外层

**常用场景：**
```java
// REQUIRED：最常用
@Transactional(propagation = Propagation.REQUIRED)
public void saveUser() {}

// REQUIRES_NEW：日志记录（不受外层事务影响）
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void saveLog() {}
```

---

### Q8：如何解决跨域问题？

**方案1：@CrossOrigin注解**
```java
@CrossOrigin(origins = "http://localhost:8080")
@RestController
public class UserController {}
```

**方案2：全局配置（推荐）**
```java
@Configuration
public class CorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedOriginPattern("*");
        config.addAllowedMethod("*");
        config.addAllowedHeader("*");
        config.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return new CorsFilter(source);
    }
}
```

**方案3：Nginx反向代理**
```nginx
location / {
    add_header Access-Control-Allow-Origin *;
}
```

---

### Q9：Spring Boot启动流程？

**核心流程（8步）：**

1. **创建SpringApplication对象**
   - 推断应用类型（Servlet/Reactive/None）
   - 加载初始化器和监听器

2. **执行run方法**
   - 创建Environment
   - 打印Banner

3. **创建ApplicationContext**
   - Servlet → AnnotationConfigServletWebServerApplicationContext

4. **准备Context**
   - 应用初始化器
   - 加载配置

5. **刷新Context**
   - 加载Bean定义
   - 实例化Bean
   - 启动内嵌Web服务器（Tomcat）

6. **自动配置生效**
   - 条件装配

7. **执行CommandLineRunner**

8. **启动完成**

---

### Q10：如何实现接口幂等性？

**方案1：Token机制（本项目可用）**
```java
// 1. 前端请求获取Token
@GetMapping("/token")
public String getToken() {
    String token = UUID.randomUUID().toString();
    redisTemplate.opsForValue().set("token:" + token, "1", 5, TimeUnit.MINUTES);
    return token;
}

// 2. 提交时校验并删除Token
@PostMapping("/submit")
public void submit(@RequestHeader("token") String token) {
    Boolean success = redisTemplate.delete("token:" + token);
    if (!success) {
        throw new CustomException("请勿重复提交");
    }
    // 业务逻辑
}
```

**方案2：数据库唯一索引**
```sql
CREATE UNIQUE INDEX uk_order_no ON `order`(order_no);
```

**方案3：分布式锁**
```java
RLock lock = redissonClient.getLock("lock:order:" + orderId);
if (lock.tryLock()) {
    try {
        // 业务逻辑
    } finally {
        lock.unlock();
    }
}
```

---

### Q11：Spring的设计模式有哪些？

**1. 单例模式** - Bean默认单例

**2. 工厂模式** - BeanFactory

**3. 代理模式** - AOP

**4. 模板方法模式** - JdbcTemplate、RedisTemplate

**5. 观察者模式** - ApplicationListener事件监听

**6. 策略模式** - 资源访问（ClassPathResource、FileSystemResource）

**7. 适配器模式** - HandlerAdapter（不同类型Controller适配）

---

### Q12：如何优雅关闭Spring Boot应用？

**方案1：优雅停机配置（2.3+）**
```yaml
server:
  shutdown: graceful  # 优雅停机
spring:
  lifecycle:
    timeout-per-shutdown-phase: 30s  # 等待时间
```

**方案2：@PreDestroy**
```java
@Component
public class GracefulShutdown {
    @PreDestroy
    public void destroy() {
        // 清理资源
        log.info("应用正在关闭...");
    }
}
```

**工作原理：**
1. 接收关闭信号（kill PID）
2. 停止接收新请求
3. 等待现有请求处理完成（最多30s）
4. 执行@PreDestroy方法
5. 关闭ApplicationContext
6. 退出JVM

---

## 六、MySQL数据库（10题）

### Q1：InnoDB和MyISAM的区别？

| 特性 | InnoDB | MyISAM |
|------|--------|--------|
| **事务** | 支持 | 不支持 |
| **外键** | 支持 | 不支持 |
| **锁粒度** | 行锁 | 表锁 |
| **MVCC** | 支持 | 不支持 |
| **崩溃恢复** | 支持（redo log） | 不支持 |
| **适用场景** | 高并发写、事务 | 读多写少 |

**本项目使用：** InnoDB（需要事务支持）

---

### Q2：索引的类型和使用场景？

**按数据结构分类：**

**1. B+树索引（默认）**
- 叶子节点存储数据
- 支持范围查询
- 查询效率稳定O(log N)

**2. Hash索引**
- 等值查询快O(1)
- 不支持范围查询
- Memory引擎支持

**按逻辑分类：**

**1. 主键索引**
```sql
PRIMARY KEY (id)
```

**2. 唯一索引**
```sql
UNIQUE KEY uk_username (username)
```

**3. 普通索引**
```sql
KEY idx_create_time (created_time)
```

**4. 联合索引**
```sql
KEY idx_user_time (user_id, created_time)
```

**本项目索引：**
```sql
-- 用户表
PRIMARY KEY (id)
UNIQUE KEY uk_username (username)

-- 结果表
PRIMARY KEY (id)
KEY idx_user_id (user_id)
KEY idx_create_time (created_time)
```

---

### Q3：MySQL的事务隔离级别？

**4种隔离级别：**

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|---------|------|-----------|------|
| **Read Uncommitted** | ✅ | ✅ | ✅ |
| **Read Committed** | ❌ | ✅ | ✅ |
| **Repeatable Read（默认）** | ❌ | ❌ | ✅ |
| **Serializable** | ❌ | ❌ | ❌ |

**InnoDB的RR解决幻读：**
- MVCC（多版本并发控制）
- Next-Key Lock（记录锁+间隙锁）

**本项目使用：** Repeatable Read（默认）

---

### Q4：explain执行计划如何分析？

**关键字段：**

**1. type（重要）**
- system > const > eq_ref > ref > range > index > ALL
- 至少达到range级别

**2. key**
- 实际使用的索引

**3. rows**
- 扫描的行数（越少越好）

**4. Extra**
- Using index：覆盖索引（最优）
- Using where：使用where过滤
- Using filesort：文件排序（需优化）
- Using temporary：临时表（需优化）

**示例：**
```sql
EXPLAIN SELECT * FROM user_result WHERE user_id = 1;

-- 优化前：type=ALL, rows=10000
-- 优化后：type=ref, key=idx_user_id, rows=10
```

---

### Q5：如何优化慢查询？

**排查步骤：**

**1. 开启慢查询日志**
```sql
SET GLOBAL slow_query_log = 1;
SET GLOBAL long_query_time = 2;  -- 2秒
```

**2. 分析执行计划**
```sql
EXPLAIN SELECT ...
```

**3. 优化手段**

**① 添加索引**
```sql
-- 优化前：全表扫描
SELECT * FROM user_result WHERE user_id = 1;

-- 添加索引
CREATE INDEX idx_user_id ON user_result(user_id);
```

**② 避免SELECT ***
```sql
-- 优化前
SELECT * FROM user_result;

-- 优化后：只查需要的字段
SELECT id, url FROM user_result;
```

**③ 分页优化**
```sql
-- 优化前：深分页慢
SELECT * FROM user_result LIMIT 100000, 10;

-- 优化后：子查询 + 主键
SELECT * FROM user_result 
WHERE id > (SELECT id FROM user_result LIMIT 100000, 1)
LIMIT 10;
```

**④ 避免函数和计算**
```sql
-- 优化前：索引失效
SELECT * FROM user_result WHERE DATE(created_time) = '2024-10-25';

-- 优化后
SELECT * FROM user_result 
WHERE created_time >= '2024-10-25 00:00:00' 
  AND created_time < '2024-10-26 00:00:00';
```

---

### Q6：MySQL的锁机制？

**锁粒度分类：**

**1. 表锁**
- 开销小，加锁快
- 并发度低
- MyISAM使用

**2. 行锁（InnoDB）**
- 开销大，加锁慢
- 并发度高
- 锁冲突概率低

**3. 间隙锁（Gap Lock）**
- 锁定索引之间的间隙
- 防止幻读
- RR级别下使用

**锁类型分类：**

**1. 共享锁（S锁，读锁）**
```sql
SELECT * FROM user WHERE id = 1 LOCK IN SHARE MODE;
```

**2. 排他锁（X锁，写锁）**
```sql
SELECT * FROM user WHERE id = 1 FOR UPDATE;
```

**本项目应用：**
```java
// 积分扣除时加排他锁，防止并发问题
@Select("SELECT * FROM user_account WHERE user_id = #{userId} FOR UPDATE")
UserAccount selectForUpdate(Long userId);
```

---

### Q7：主从复制原理？

**工作流程（3步）：**

**1. Master写入binlog**
```
主库执行写操作
 ↓
写入binlog（二进制日志）
 ↓
通知Slave
```

**2. Slave的IO线程读取binlog**
```
Slave的IO线程连接Master
 ↓
读取binlog
 ↓
写入Relay Log（中继日志）
```

**3. Slave的SQL线程重放**
```
SQL线程读取Relay Log
 ↓
重放SQL语句
 ↓
完成同步
```

**延迟问题：**
- 主从同步是异步的，存在延迟
- 解决：读写分离时，强一致性查询走主库

---

### Q8：如何设计数据库表？

**本项目表设计示例：**

**用户表（sg_user）**
```sql
CREATE TABLE sg_user (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL COMMENT '用户名',
    password VARCHAR(100) NOT NULL COMMENT '密码',
    phone VARCHAR(11) COMMENT '手机号',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_username (username),
    KEY idx_phone (phone)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```

**账户表（sg_user_account）**
```sql
CREATE TABLE sg_user_account (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '用户ID',
    total_amount DECIMAL(10,2) DEFAULT 0 COMMENT '总账户',
    freeze_amount DECIMAL(10,2) DEFAULT 0 COMMENT '冻结账户',
    available_amount DECIMAL(10,2) DEFAULT 0 COMMENT '可用账户',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_user_id (user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='账户表';
```

**结果表（sg_user_result）**
```sql
CREATE TABLE sg_user_result (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '用户ID',
    url VARCHAR(500) NOT NULL COMMENT '图片URL',
    collect TINYINT DEFAULT 0 COMMENT '是否收藏',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    KEY idx_user_id (user_id),
    KEY idx_create_time (created_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='结果表';
```

**设计原则：**
- 主键自增
- 合理建立索引
- 字段注释清晰
- 使用InnoDB引擎
- 自动维护时间戳

---

### Q9：MyBatis Plus的常用功能？

**1. 自动填充**
```java
@TableField(fill = FieldFill.INSERT)
private LocalDateTime createdTime;

@TableField(fill = FieldFill.INSERT_UPDATE)
private LocalDateTime updatedTime;
```

**2. 逻辑删除**
```java
@TableLogic
private Integer deleted;  // 0-未删除 1-已删除
```

**3. 乐观锁**
```java
@Version
private Integer version;
```

**4. Lambda查询**
```java
List<User> users = userMapper.selectList(
    new LambdaQueryWrapper<User>()
        .eq(User::getUsername, "admin")
        .gt(User::getAge, 18)
);
```

**5. 分页查询**
```java
Page<User> page = new Page<>(1, 10);
userMapper.selectPage(page, null);
```

---

### Q10：SQL注入如何防止？

**危险示例（拼接SQL）：**
```java
// ❌ 危险：SQL注入
String sql = "SELECT * FROM user WHERE username = '" + username + "'";
// 输入：admin' OR '1'='1
// 结果：SELECT * FROM user WHERE username = 'admin' OR '1'='1'
```

**安全方案：**

**1. 预编译（推荐）**
```java
// ✅ 安全：MyBatis的#{}
@Select("SELECT * FROM user WHERE username = #{username}")
User selectByUsername(String username);
```

**2. 参数化查询**
```java
PreparedStatement pstmt = conn.prepareStatement(
    "SELECT * FROM user WHERE username = ?"
);
pstmt.setString(1, username);
```

**3. 输入校验**
```java
// 校验用户名格式
if (!username.matches("[a-zA-Z0-9_]+")) {
    throw new IllegalArgumentException("用户名格式错误");
}
```

**MyBatis的#{}和${}区别：**
- `#{}` - 预编译，安全（推荐）
- `${}` - 字符串替换，有SQL注入风险

---

## 七、并发与JVM（8题）

### Q1：ThreadLocal的原理和内存泄漏？

**原理：**
```java
// 每个Thread对象都有一个ThreadLocalMap
class Thread {
    ThreadLocal.ThreadLocalMap threadLocals;
}

// ThreadLocalMap是一个特殊的Map
// Key: ThreadLocal对象（弱引用）
// Value: 实际存储的值（强引用）
```

**本项目使用：**
```java
public class UserUtils {
    private static final ThreadLocal<User> USER_THREAD_LOCAL = new ThreadLocal<>();
    
    public static void saveUser(User user) {
        USER_THREAD_LOCAL.set(user);
    }
    
    public static User getUser() {
        return USER_THREAD_LOCAL.get();
    }
    
    public static void removeUser() {
        USER_THREAD_LOCAL.remove();  // 必须清理
    }
}
```

**内存泄漏原理：**

1. **Entry的Key是弱引用**
```java
static class Entry extends WeakReference<ThreadLocal<?>> {
    Object value;  // value是强引用
}
```

2. **泄漏场景**
```
ThreadLocal被回收 → Key变为null
但value是强引用 → value无法回收
Thread不销毁（线程池） → Entry一直存在
→ 内存泄漏
```

3. **解决方案**
```java
// 拦截器中使用完必须清理
@Override
public void afterCompletion(...) {
    UserUtils.removeUser();  // ✅ 清理ThreadLocal
}
```

---

### Q2：volatile关键字的作用？

**两大作用：**

**1. 保证可见性**
```java
// 线程A修改flag，线程B立即看到
private volatile boolean flag = false;

// 线程A
flag = true;

// 线程B
while (!flag) {
    // 能立即退出循环
}
```

**2. 禁止指令重排序**
```java
// 单例模式的双重检查锁
public class Singleton {
    // 必须加volatile
    private static volatile Singleton instance;
    
    public static Singleton getInstance() {
        if (instance == null) {  // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) {  // 第二次检查
                    instance = new Singleton();  // 禁止重排序
                }
            }
        }
        return instance;
    }
}
```

**为什么需要volatile：**
```
new Singleton()分为3步：
1. 分配内存
2. 初始化对象
3. 指向内存地址

重排序可能变成1→3→2
线程B看到instance != null，但对象还没初始化
→ 使用未初始化的对象
→ 空指针异常

volatile禁止重排序，保证1→2→3顺序
```

---

### Q3：synchronized和Lock的区别？

| 特性 | synchronized | Lock (ReentrantLock) |
|------|-------------|---------------------|
| **获取方式** | 自动获取/释放 | 手动lock()/unlock() |
| **灵活性** | 低 | 高 |
| **公平锁** | 非公平 | 可选公平/非公平 |
| **可中断** | 不可中断 | 可中断 |
| **性能** | JDK 6后优化，差距小 | 稍高 |
| **条件变量** | 1个（wait/notify） | 多个（Condition） |

**synchronized示例：**
```java
public synchronized void method() {
    // 业务逻辑
}

// 等价于
public void method() {
    synchronized (this) {
        // 业务逻辑
    }
}
```

**Lock示例：**
```java
private final ReentrantLock lock = new ReentrantLock();

public void method() {
    lock.lock();
    try {
        // 业务逻辑
    } finally {
        lock.unlock();  // 必须在finally中释放
    }
}
```

**选择建议：**
- 简单场景：synchronized（代码简洁）
- 复杂场景：Lock（功能更强大）

---

### Q4：JVM内存结构？

**运行时数据区（5部分）：**

**1. 程序计数器（线程私有）**
- 记录当前线程执行的字节码行号

**2. 虚拟机栈（线程私有）**
- 方法调用时创建栈帧
- 存储局部变量、操作数栈

**3. 本地方法栈（线程私有）**
- 为Native方法服务

**4. 堆（线程共享）**
- 存储对象实例
- GC主要区域
- 分为年轻代和老年代

**5. 方法区（线程共享）**
- 存储类信息、常量、静态变量
- JDK 8后改为元空间（Metaspace）

---

### Q5：垃圾回收算法？

**4种算法：**

**1. 标记-清除**
- 标记存活对象
- 清除未标记对象
- 缺点：内存碎片

**2. 标记-复制**
- 将存活对象复制到另一块内存
- 优点：无碎片
- 缺点：浪费50%内存
- 用于：年轻代（Eden + Survivor）

**3. 标记-整理**
- 标记存活对象
- 整理到一端，清除另一端
- 用于：老年代

**4. 分代收集（主流）**
- 年轻代：复制算法
- 老年代：标记-整理

**GC类型：**
- Minor GC：年轻代GC
- Major GC：老年代GC
- Full GC：全堆GC

---

### Q6：如何排查OOM问题？

**排查步骤：**

**1. 查看错误日志**
```
java.lang.OutOfMemoryError: Java heap space  // 堆内存溢出
java.lang.OutOfMemoryError: PermGen space     // 永久代溢出（JDK 7）
java.lang.OutOfMemoryError: Metaspace         // 元空间溢出（JDK 8+）
```

**2. 生成堆转储文件**
```bash
# JVM启动参数
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/logs/heapdump.hprof
```

**3. 分析堆转储文件**
```bash
# 使用MAT（Memory Analyzer Tool）分析
# 找出占用内存最多的对象
```

**常见原因：**
- 内存泄漏（对象无法回收）
- 内存不足（堆设置太小）
- 创建大对象（数组、集合）
- ThreadLocal未清理

---

### Q7：常用的JVM参数？

**堆大小设置：**
```bash
-Xms2g           # 初始堆大小2G
-Xmx2g           # 最大堆大小2G（建议与Xms相同）
-Xmn512m         # 年轻代大小512M
-Xss256k         # 每个线程栈大小256K
```

**GC相关：**
```bash
-XX:+UseG1GC                    # 使用G1垃圾收集器
-XX:MaxGCPauseMillis=200        # 最大GC停顿时间200ms
-XX:+PrintGCDetails             # 打印GC详情
-XX:+PrintGCDateStamps          # 打印GC时间戳
```

**OOM时生成dump：**
```bash
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/logs/heapdump.hprof
```

**本项目推荐配置：**
```bash
java -jar app.jar \
  -Xms1g -Xmx1g \
  -XX:+UseG1GC \
  -XX:+HeapDumpOnOutOfMemoryError \
  -XX:HeapDumpPath=/logs/dump.hprof
```

---

### Q8：线程池的核心参数？

**7个核心参数：**
```java
public ThreadPoolExecutor(
    int corePoolSize,              // 核心线程数
    int maximumPoolSize,           // 最大线程数
    long keepAliveTime,            // 空闲线程存活时间
    TimeUnit unit,                 // 时间单位
    BlockingQueue<Runnable> workQueue,  // 工作队列
    ThreadFactory threadFactory,   // 线程工厂
    RejectedExecutionHandler handler  // 拒绝策略
)
```

**工作流程：**
```
1. 任务提交
   ↓
2. 核心线程数未满？
   是 → 创建核心线程执行
   否 ↓
3. 队列未满？
   是 → 放入队列
   否 ↓
4. 最大线程数未满？
   是 → 创建非核心线程执行
   否 ↓
5. 执行拒绝策略
```

**拒绝策略：**
- AbortPolicy：抛异常（默认）
- CallerRunsPolicy：调用者线程执行
- DiscardPolicy：丢弃任务
- DiscardOldestPolicy：丢弃队列最旧任务

**示例：**
```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    5,                           // 核心线程5
    10,                          // 最大线程10
    60, TimeUnit.SECONDS,        // 空闲60秒回收
    new LinkedBlockingQueue<>(100),  // 队列容量100
    Executors.defaultThreadFactory(),
    new ThreadPoolExecutor.AbortPolicy()
);
```

---

## 八、WebSocket专题（6题)
   - Redis集群、读写分离、分库分表

2. **高可用设计**
   - ComfyUI服务挂了怎么办
   - Redis挂了怎么办
   - 如何实现服务降级

3. **监控与运维**
   - 如何监控系统性能
   - 如何排查线上问题
   - 日志收集与分析

4. **未来改进方向**
   - 引入消息队列（Kafka）
   - 微服务拆分
   - 容器化部署（Docker + K8s）
# 星图项目 - 面试介绍逐字稿

## 🎤 版本一：技术深度版（2分钟，适合技术面试）

### 开场

> "您好，我来介绍一下这个AI图像生成平台项目。这是一个基于ComfyUI的SaaS系统，用户可以通过输入文字描述生成图片。我在这个项目中主要负责后端核心功能的设计和开发。"

### 核心问题与解决方案

> **"在技术实现上，我重点解决了三个核心问题："**
>
> **"第一个是分布式任务队列管理。"**  
> 因为AI图片生成比较耗时，用户不能一直等待，所以我设计了一个基于Redis的任务队列系统。
>
> 具体来说，我使用Redis的 **ZSet数据结构** 实现了优先级队列。当用户提交任务时，系统先冻结对应积分，然后根据提交时间生成score加入ZSet，score越小优先级越高。我还实现了 **插队功能**，用户可以消耗额外积分提升优先级，本质上就是减小任务的score值。
>
> 为了防止并发操作导致的数据不一致问题，我使用Redis的 **SETNX命令** 配合 **Lua脚本** 实现了分布式锁。Lua脚本保证了"判断锁是否是自己的"和"删除锁"这两步操作的原子性，避免了误删其他线程的锁。

> **"第二个是实时消息推送架构。"**  
> 这个项目涉及 **两个WebSocket连接**，这一点比较有特色：
>
> 一个是作为WebSocket **客户端** 连接ComfyUI服务，接收任务状态消息。ComfyUI在任务执行过程中会推送progress（进度）、executed（完成）、execution_error（失败）等消息。
>
> 另一个是作为WebSocket **服务端**，基于 **STOMP协议** 向前端推送实时进度。我实现了点对点推送机制，通过clientId精准推送给目标用户。
>
> 消息流转路径是：ComfyUI → 我们的Spring Boot应用 → 前端浏览器。中间我会进行业务处理，比如保存图片到数据库、扣除积分、释放信号量等。

> **"第三个是并发控制。"**  
> ComfyUI服务器有性能限制，不能同时处理太多任务，否则会GPU内存不足。所以我使用Redis的 **Semaphore信号量** 机制，通过信号量控制并发任务数，避免GPU资源过载。
>
> 我设计了一个定时任务，每秒扫描一次队列。首先尝试获取信号量，如果获取成功，就从队列中ZPOPMIN取出优先级最高的任务提交给ComfyUI。当任务完成时，在finally块中释放信号量，确保不会发生信号量泄漏。

### 业务设计

> **"在业务设计上，"**  
> 我实现了完整的积分流转机制。用户提交任务时冻结积分，任务成功后从冻结账户扣除到系统总账户，任务失败则退回到可用账户。整个流程使用Spring的 **@Transactional注解** 保证原子性，确保积分不会多扣或少扣。

### 项目成果

> **"项目上线后"** 运行稳定，实时推送准确率达到100%，用户反馈体验流畅。我还对整个项目的代码进行了详细注释，注释覆盖率达到90%以上，便于团队协作和后续维护。

### 结尾

> "以上就是这个项目的核心技术实现，如果您对某个部分感兴趣，我可以展开详细说明。"

---

## 🎤 版本二：业务理解版（1.5分钟，适合综合面试）

### 开场

> "这个项目是一个AI图像生成平台，类似于Midjourney或者Stable Diffusion。用户输入文字描述，比如'一只猫坐在月亮上'，系统就能生成相应的图片。"

### 业务价值

> **"这个项目解决的核心问题是："** 如何让普通用户也能使用专业的AI绘图工具。ComfyUI本身是一个专业的AI工作流引擎，使用门槛比较高。我们通过封装，让用户只需要输入文字就能生成图片。

### 核心功能

> **"我在这个项目中主要负责四大模块："**

> **"任务调度系统："**  
> 因为AI生成图片需要时间，不能让用户一直等待。我设计了一个基于Redis的任务队列，用户提交任务后立即返回，系统在后台按顺序处理。我还实现了VIP插队功能，允许付费用户消耗额外积分优先生成。

> **"实时进度推送："**  
> 用户提交任务后可以实时看到进度，比如"正在处理，已完成30%"。我使用WebSocket技术实现双向通信，当后台AI引擎推送进度时，前端页面能立即更新显示，用户体验很好。

> **"AI智能翻译："**  
> 因为底层的ComfyUI对英文提示词效果更好，我集成了Ollama大语言模型，自动将用户的中文描述翻译成英文，大大提高了生成图片的质量。用户完全感知不到这个翻译过程。

> **"积分管理系统："**  
> 每次生成图片需要消耗积分。我设计了预扣机制：提交任务时先冻结积分，成功后扣除，失败则退还。这样既能防止恶意刷量，又保证了用户权益，不会出现失败了还扣钱的情况。

### 技术挑战

> **"技术上的主要挑战是并发控制和分布式协调。"**  
> 我使用Redis分布式锁解决了并发操作冲突的问题，比如多个用户同时取消同一个任务。用信号量控制了后台AI引擎的并发数量，避免服务器过载。用Spring的事务机制保证了积分扣除的一致性。

### 项目成果

> **"最终交付的系统"** 性能稳定，支持多用户并发使用，实时推送功能准确可靠，用户反馈很好。

### 结尾

> "这就是这个项目的整体情况，如果您想了解某个技术细节，我很乐意展开介绍。"

---

## 🎤 版本三：简洁版（30秒，电梯演讲）

> "这是一个AI图像生成平台，用户输入文字就能生成图片。"
>
> "我负责后端开发，主要实现了三个核心功能："
>
> **"一是基于Redis ZSet的任务队列系统，"** 支持优先级排队和动态插队；
>
> **"二是WebSocket实时推送，"** 让用户能看到任务进度和生成结果；
>
> **"三是分布式锁和信号量机制，"** 保证高并发场景下的数据一致性和系统稳定性。
>
> "技术栈主要是Spring Boot、Redis、WebSocket和Retrofit。项目运行稳定，用户体验流畅。"

---

## 💡 面试时的应对策略

### 如果面试官追问技术细节

#### Q："Redis ZSet是怎么实现优先级的？"
**A：** 
> "ZSet是有序集合，每个成员都有一个score值。我用提交时间的毫秒数作为score，这样自然就按时间排序了。当用户插队时，我会减小它的score，让它排到前面。底层ZSet使用跳表实现，插入和查询都是O(log N)的时间复杂度，性能很好。"

#### Q："为什么用Lua脚本？"
**A：** 
> "因为解锁需要两步操作：先判断锁是不是自己的，再删除锁。如果分开执行，中间可能被其他线程打断，导致删除了别人的锁。Lua脚本在Redis中是原子执行的，能保证这两步的原子性。代码类似：if redis.call('get', key) == value then return redis.call('del', key) end"

#### Q："WebSocket为什么用STOMP协议？"
**A：** 
> "原生WebSocket只提供双向通信能力，没有定义消息格式和路由规则。STOMP是一个应用层协议，提供了发布/订阅模式，支持主题订阅。我用/user前缀实现点对点推送，Spring会自动处理消息路由。而且浏览器有现成的stomp.js库，开发很方便。"

### 如果面试官追问性能优化

#### Q："如果用户量增长10倍，怎么优化？"
**A：** 
> "主要有几个方向：一是Redis集群，做主从复制和读写分离；二是ComfyUI水平扩展，部署多个实例做负载均衡；三是引入消息队列如Kafka做削峰填谷；四是数据库分库分表。我会先做压测，找出最严重的瓶颈点，然后针对性优化。"

### 如果面试官追问业务理解

#### Q："为什么要设计插队功能？"
**A：** 
> "主要有两个考虑：一是商业模式，VIP用户愿意付费获得更好的服务；二是用户体验，如果用户很着急，可以选择插队。从技术上说，因为用的是ZSet，修改优先级很容易，时间复杂度O(log N)。这比传统消息队列要灵活得多。"

#### Q："任务失败了为什么要退款？"
**A：** 
> "这是保护用户权益。AI生成可能因为各种原因失败，比如ComfyUI服务异常、参数错误等。如果失败了还扣钱，用户体验会很差。所以我设计了三账户模型：提交时冻结积分，成功时扣除，失败时退回。这样既能防止恶意刷量，又保证了公平。"

---

## 🎯 模拟面试场景

### 场景一：HR或业务面试

**面试官**："请简单介绍一下这个项目。"

**你**："这是一个AI图像生成平台，用户输入文字就能生成图片。我负责后端开发，主要实现了任务队列管理、实时消息推送和积分系统。系统支持多用户并发，实时推送准确率100%，用户反馈很好。"

（简洁、突出业务价值和成果）

### 场景二：技术主管面试

**面试官**："请详细介绍一下这个项目的技术架构。"

**你**：（使用版本一：技术深度版，重点讲三个核心问题）

### 场景三：面试官沉默

**你**："...以上就是这个项目的核心技术实现。特别值得一提的是Redis分布式锁和WebSocket双向通信这两块，如果您感兴趣，我可以详细展开说明它们的实现原理。或者如果您有任何问题，欢迎提问。"

（主动引导面试官提问，掌握主动权）

# 星图项目 - 核心面试题（上）

## 1. Redis ZSet实现优先级队列

**Q：详细说说你是如何用Redis ZSet实现优先级队列的？**

**A：使用ZSet的score作为优先级，score越小优先级越高**

**数据结构：**
- Key: `queue:text2image`
- Member: 任务ID（tempId）
- Score: 时间戳（毫秒）

**核心操作：**
```java
// 入队：ZADD queue:text2image <timestamp> <taskId>
// 出队：ZPOPMIN queue:text2image 1  // 弹出最小score
// 查询位置：ZRANK queue:text2image <taskId>
// 删除：ZREM queue:text2image <taskId>
// 插队：减小score，ZADD覆盖
```

**插队实现：**
```java
// 获取当前score和排名
Long rank = redisTemplate.opsForZSet().rank(key, taskId);
Double currentScore = redisTemplate.opsForZSet().score(key, taskId);

// 如果已是第一名，不能插队
if (rank == 0) throw new CustomException("已经是第一名");

// 减小score，提升优先级
double newScore = currentScore - 10;
redisTemplate.opsForZSet().add(key, taskId, newScore);
```

**为什么选ZSet：**
- 自动排序，O(log N)时间复杂度
- 支持随机访问（取消/插队）
- 底层跳表实现，性能高

---

## 2. 分布式锁实现

**Q：如何实现分布式锁？为什么用Lua脚本？**

**A：使用SET NX EX + Lua脚本保证原子性**

**加锁：**
```java
SET lock:task:<taskId> <uuid> NX EX 10
// NX: key不存在时才设置
// EX 10: 10秒自动过期（防死锁）
// uuid: 唯一标识（防误删）
```

**解锁（Lua脚本）：**
```lua
if redis.call("get", KEYS[1]) == ARGV[1] then
    return redis.call("del", KEYS[1])
else
    return 0
end
```

**为什么必须用Lua：**
- GET和DEL两步操作需要原子性
- 不用Lua会导致：
  1. 线程A判断是自己的锁
  2. 锁过期，线程B获取了锁
  3. 线程A执行DEL，删除了线程B的锁！
- Lua脚本在Redis中原子执行，避免竞态

**为什么用UUID：**
- 防止误删其他线程的锁
- 每个线程的锁有唯一标识
- 只能删除自己的锁

---

## 3. Redis信号量控制并发

**Q：Redis信号量如何控制ComfyUI并发？**

**A：使用Redisson的RSemaphore控制并发数**

**代码实现：**
```java
// 获取信号量
RSemaphore semaphore = redissonClient.getSemaphore("TASK_RUN_SEMAPHORE");

// 尝试获取一个许可
boolean acquired = semaphore.tryAcquire();
if (acquired) {
    try {
        // 提交任务到ComfyUI
        sendTaskToComfyui();
    } finally {
        // 任务失败时也要释放
        semaphore.release();
    }
}
```

**工作流程：**
```
定时任务每秒扫描 → 尝试获取信号量 
→ 成功：从队列取任务提交ComfyUI 
→ 失败：当前并发已满，等待下次扫描
→ 任务完成：释放信号量
```

**信号量初始化：**

⚠️ **注意**：代码中没有调用 `trySetPermits()` 初始化许可数！

实际项目中需要通过以下方式之一初始化：
1. **在Redis中手动设置**：`SET TASK_RUN_SEMAPHORE 10`
2. **在应用启动时初始化**：
   ```java
   @PostConstruct
   public void init() {
       RSemaphore semaphore = redissonClient.getSemaphore("TASK_RUN_SEMAPHORE");
       semaphore.trySetPermits(10); // 根据服务器配置设置
   }
   ```
3. **第一次手动release几次**来增加初始许可

**并发数设置依据：**
- 根据ComfyUI服务器GPU资源决定
- 太多并发导致GPU内存不足（OOM）
- 需要根据GPU显存大小测试最优值

**防止信号量泄漏：**
- 必须在finally块中释放
- 即使任务失败也要释放
- 否则信号量永久占用，系统阻塞

---

## 4. 两个WebSocket连接

**Q：项目中有两个WebSocket连接，有什么区别？**

**A：一个客户端连接ComfyUI，一个服务端连接前端**

**WebSocket客户端（连接ComfyUI）：**
- 角色：客户端
- 连接：Spring Boot → ComfyUI
- 用途：接收AI任务状态消息
- 消息类型：progress（进度）、executed（完成）、execution_error（失败）
- 实现：StandardWebSocketClient

**WebSocket服务端（连接前端）：**
- 角色：服务端
- 连接：前端浏览器 → Spring Boot
- 用途：向前端推送实时进度和结果
- 协议：STOMP over WebSocket
- 实现：@EnableWebSocketMessageBroker

**消息流转：**
```
ComfyUI → [WS客户端] → Spring Boot（业务处理） 
→ [WS服务端] → 前端
```

**为什么需要两个：**
- ComfyUI不直接与前端通信
- Spring Boot作为中间层进行业务处理
- 保存数据库、扣除积分、释放信号量

---

## 5. STOMP协议

**Q：STOMP协议是什么？为什么用它？**

**A：应用层消息协议，提供发布/订阅模式**

**原生WebSocket的局限：**
- 只提供双向通信，没有消息格式定义
- 没有路由机制（怎么实现点对点、广播？）
- 需要自己实现订阅管理

**STOMP提供：**
- 标准化的消息帧格式（CONNECT、SUBSCRIBE、MESSAGE等）
- 发布/订阅模式
- 点对点通信（/user前缀）
- 主题订阅（/topic前缀）

**使用示例：**
```java
// 后端：点对点推送
simpMessagingTemplate.convertAndSendToUser(
    userId, "/topic/messages", data
);

// 前端：订阅
stompClient.subscribe('/user/topic/messages', callback);
```

**如果不用STOMP：**
- 需要自己定义消息格式
- 需要自己实现路由逻辑
- 需要管理订阅关系
- STOMP帮我们做了这些

---

## 6. ThreadLocal使用

**Q：ThreadLocal在项目中如何使用？为什么必须清理？**

**A：存储登录用户信息，避免方法间传参**

**使用方式：**
```java
// 拦截器存储
public boolean preHandle(...) {
    User user = JwtUtils.parseToken(token);
    UserUtils.saveUser(user); // 存入ThreadLocal
    return true;
}

// Service获取
Long userId = UserUtils.getUser().getId();

// 拦截器清理
public void afterCompletion(...) {
    UserUtils.removeUser(); // 必须清理
}
```

**为什么用ThreadLocal：**
- 避免在方法间层层传递user参数
- 线程隔离，不同请求互不影响
- 类似"请求级别的全局变量"

**为什么必须清理：**
- Tomcat使用线程池，线程会被复用
- 不清理会导致下一个请求读到上一个用户的信息（安全问题！）
- 造成内存泄漏（ThreadLocal持有的对象无法GC）

**清理时机：**
- 在afterCompletion()中清理（finally语义）
- 无论请求成功还是失败都会调用
- 保证ThreadLocal一定被清理

---

## 7. 积分扣除的原子性

**Q：如何保证积分扣除的原子性？**

**A：使用@Transactional注解**

**事务管理：**
```java
@Transactional
public void saveList(List<String> urls, Long userId) {
    // 1. 批量保存图片记录
    userResultMapper.insertBatch(urls, userId);
    
    // 2. 扣除冻结积分
    userFundRecordService.deduct(userId, urls.size());
    
    // 两步操作在同一事务中
    // 要么都成功，要么都回滚
}
```

**积分流转状态机：**
- 提交任务：可用 → 冻结（freeze）
- 任务成功：冻结 → 扣除（deduct）
- 任务失败：冻结 → 返还（freezeReturn）

**数据库层面：**
- 使用MyBatis Plus的乐观锁（version字段）
- 或使用SELECT FOR UPDATE（悲观锁）
- 防止并发修改导致的超扣问题

**异常处理：**
```java
try {
    comfyuiApi.prompt(workflow);
} catch (Exception e) {
    // 失败时退还积分
    userFundRecordService.freezeReturn(userId, amount);
}
```

---

## 8. 系统瓶颈与优化

**Q：如果用户量增长10倍，系统会遇到什么瓶颈？**

**A：主要有5个瓶颈点**

**1. Redis单点瓶颈**
- 优化：主从复制、读写分离、Redis Cluster

**2. MySQL性能瓶颈**
- 优化：读写分离、分库分表、建立索引、缓存热点数据

**3. ComfyUI处理能力**
- 优化：水平扩展（多GPU服务器）、负载均衡

**4. WebSocket连接数**
- 优化：使用Netty、连接池管理、降低推送频率

**5. 定时任务性能**
- 优化：多线程处理、分布式定时任务（XXL-JOB）

**架构升级：**
- 引入消息队列（Kafka）
- 微服务拆分
- API网关（限流、熔断、降级）
- 监控告警（Prometheus + Grafana）

---

## 9. 为什么选Redis而不是消息队列

**Q：为什么用Redis而不是RabbitMQ/Kafka？**

**A：Redis更适合这个场景**

**Redis的优势：**
1. **需求匹配**：ZSet天然支持优先级排序
2. **随机访问**：支持取消/插队，O(log N)操作
3. **技术栈统一**：项目已用Redis做锁和缓存
4. **性能**：基于内存，延迟低

**消息队列的特点：**
- 适合海量消息（百万级TPS）
- FIFO，修改优先级困难
- 需要额外部署和维护

**什么时候用MQ：**
- 分布式微服务架构
- 需要消息持久化和可靠性
- 复杂的消息路由

---

## 10. 定时任务扫描队列

**Q：定时任务是如何扫描队列的？**

**A：每秒扫描一次，获取信号量后取任务**

**实现：**
```java
@Scheduled(fixedRate = 1000) // 每秒执行
public void scanQueue() {
    // 1. 尝试获取信号量
    RSemaphore semaphore = redissonClient.getSemaphore("semaphore:comfyui");
    boolean acquired = semaphore.tryAcquire(1, 0, TimeUnit.SECONDS);
    
    if (!acquired) {
        return; // 并发已满，下次再试
    }
    
    try {
        // 2. 从队列取出最高优先级任务
        String taskId = (String) redisTemplate.opsForZSet()
            .popMin("queue:text2image");
        
        if (taskId == null) {
            semaphore.release(1); // 队列为空，释放信号量
            return;
        }
        
        // 3. 获取任务详情
        String taskJson = redisTemplate.opsForValue().get("task:" + taskId);
        Task task = JSON.parseObject(taskJson, Task.class);
        
        // 4. 翻译提示词
        String englishPrompt = ollamaService.translate(task.getPrompt());
        
        // 5. 生成工作流JSON
        String workflow = freemarkerService.renderText2Image(task);
        
        // 6. 提交ComfyUI
        comfyuiApi.prompt(workflow);
        
    } catch (Exception e) {
        log.error("任务提交失败", e);
        semaphore.release(1); // 失败也要释放
    }
}
```

**为什么每秒扫描：**
- 平衡响应速度和系统负载
- 太频繁浪费CPU
- 太慢影响用户体验

---

查看《面试题库（下）》获取更多面试题！
# 星图项目 - 核心面试题（下）

## 11. ThreadLocal详解

**Q：ThreadLocal如何使用？为什么必须清理？会导致什么问题？**

**A：存储用户上下文，避免参数传递**

**使用方式：**
```java
// 工具类
public class UserUtils {
    private static final ThreadLocal<User> USER_THREAD_LOCAL = new ThreadLocal<>();
    
    public static void saveUser(User user) {
        USER_THREAD_LOCAL.set(user);
    }
    
    public static User getUser() {
        return USER_THREAD_LOCAL.get();
    }
    
    public static void removeUser() {
        USER_THREAD_LOCAL.remove(); // 必须清理！
    }
}

// 拦截器中设置
@Override
public boolean preHandle(...) {
    User user = JwtUtils.parseToken(token);
    UserUtils.saveUser(user);
    return true;
}

// Service中获取
public void submitTask() {
    Long userId = UserUtils.getUser().getId(); // 直接获取，无需传参
}

// 拦截器中清理
@Override
public void afterCompletion(...) {
    UserUtils.removeUser(); // 请求结束后必须清理
}
```

**为什么用ThreadLocal：**
- 避免在Controller → Service → Mapper层层传递user参数
- 线程隔离：每个HTTP请求对应一个线程，互不影响
- 类似"请求级别的全局变量"

**为什么必须清理：**

1. **安全问题：数据串了**
```
线程A：处理用户1的请求，设置ThreadLocal = User1
请求结束，没有清理
---
线程A被复用：处理用户2的请求
Service中获取：UserUtils.getUser() → 返回User1（错了！）
结果：用户2看到了用户1的数据！
```

2. **内存泄漏**
```
ThreadLocal内部结构：
Thread → ThreadLocalMap → Entry[] → Entry(key, value)
                                      ↓
                                   弱引用key, 强引用value

key是弱引用：ThreadLocal对象被GC后，key变为null
value是强引用：User对象无法被GC，造成内存泄漏

线程池场景：线程不销毁，ThreadLocalMap一直存在
→ 越来越多的null key + 强引用value
→ 内存泄漏
```

**清理时机：**
- 在`afterCompletion()`中清理（finally语义）
- 无论请求成功、失败、异常，都会调用
- Spring拦截器的生命周期保证一定执行

**底层原理：**
```java
// Thread类中的字段
ThreadLocal.ThreadLocalMap threadLocals;

// ThreadLocalMap是一个特殊的Map
Entry[] table; // 数组存储
Entry extends WeakReference<ThreadLocal<?>> {
    Object value; // 强引用
}

// set操作
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = t.threadLocals;
    if (map != null) {
        map.set(this, value);
    } else {
        createMap(t, value);
    }
}
```

---

## 12. Spring事务@Transactional

**Q：如何保证积分扣除的原子性？@Transactional失效的场景有哪些？**

**A：使用@Transactional注解，保证操作原子性**

**使用示例：**
```java
@Transactional
public void saveList(List<String> urls, Long userId) {
    // 1. 批量保存图片记录到数据库
    userResultMapper.insertBatch(urls, userId);
    
    // 2. 从冻结账户扣除积分到系统总账户
    userFundRecordService.deduct(userId, urls.size());
    
    // 两步操作在同一事务中
    // 要么都成功，要么都回滚
}
```

**积分流转状态机：**
```
提交任务：可用账户 → 冻结账户 (freeze)
任务成功：冻结账户 → 系统总账户 (deduct)
任务失败：冻结账户 → 可用账户 (freezeReturn)
任务取消：冻结账户 → 可用账户 (freezeReturn)
```

**@Transactional失效的7种场景：**

**1. 方法不是public**
```java
@Transactional
private void transfer() { } // 失效！Spring AOP只代理public方法
```

**2. 自调用问题**
```java
@Service
public class UserService {
    public void methodA() {
        this.methodB(); // 失效！没有走代理
    }
    
    @Transactional
    public void methodB() { }
}

// 解决方案：注入自己
@Autowired
private UserService self;

public void methodA() {
    self.methodB(); // 生效，走代理
}
```

**3. 异常类型不对**
```java
@Transactional
public void transfer() {
    // ...
    throw new Exception(); // 失效！默认只回滚RuntimeException
}

// 解决方案：指定异常类型
@Transactional(rollbackFor = Exception.class)
```

**4. 异常被捕获**
```java
@Transactional
public void transfer() {
    try {
        // 业务逻辑
    } catch (Exception e) {
        e.printStackTrace(); // 失效！异常被吃掉了
    }
}

// 解决方案：重新抛出
catch (Exception e) {
    log.error("转账失败", e);
    throw e; // 或 throw new RuntimeException(e);
}
```

**5. 数据库不支持事务**
```java
// MyISAM引擎不支持事务，只有InnoDB支持
CREATE TABLE user (id INT) ENGINE=MyISAM; // 失效！
```

**6. 没有被Spring管理**
```java
public class UserService { // 没有@Service注解
    @Transactional
    public void transfer() { } // 失效！不是Spring Bean
}
```

**7. 传播行为配置错误**
```java
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public void transfer() { } // 失效！以非事务方式执行
```

**事务传播行为：**
```
REQUIRED（默认）：如果有事务就加入，没有就新建
REQUIRES_NEW：总是新建事务，挂起当前事务
NESTED：嵌套事务，外层回滚影响内层，内层回滚不影响外层
SUPPORTS：有事务就加入，没有就以非事务执行
NOT_SUPPORTED：以非事务方式执行，挂起当前事务
NEVER：以非事务方式执行，如果有事务就抛异常
MANDATORY：必须在事务中执行，否则抛异常
```

---

## 13. 全局异常处理

**Q：系统的异常处理策略是什么？**

**A：三层异常处理机制**

**1. Controller层（全局异常处理）**
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    // 业务异常
    @ExceptionHandler(CustomException.class)
    public Result handleCustomException(CustomException e) {
        log.warn("业务异常: {}", e.getMessage());
        return Result.error(e.getMessage());
    }
    
    // 参数校验异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result handleValidException(MethodArgumentNotValidException e) {
        String message = e.getBindingResult().getFieldError().getDefaultMessage();
        return Result.error("参数校验失败: " + message);
    }
    
    // 系统异常
    @ExceptionHandler(Exception.class)
    public Result handleException(Exception e) {
        log.error("系统异常", e);
        return Result.error("系统繁忙，请稍后重试");
    }
}
```

**2. Service层（业务异常）**
```java
public void submitTask(TaskDTO taskDTO) {
    // 参数校验
    if (taskDTO.getPrompt() == null) {
        throw new CustomException("提示词不能为空");
    }
    
    // 业务规则
    if (user.getBalance() < 10) {
        throw new CustomException("积分不足，请先充值");
    }
    
    // 资源检查
    Task task = taskMapper.selectById(taskId);
    if (task == null) {
        throw new CustomException("任务不存在");
    }
}
```

**3. 资源清理（finally）**
```java
RLock lock = redissonClient.getLock("lock:task:" + taskId);
try {
    lock.lock();
    // 执行业务逻辑
} catch (CustomException e) {
    // 业务异常：归还积分
    userFundRecordService.freezeReturn(userId, amount);
    throw e;
} catch (Exception e) {
    // 系统异常：记录日志
    log.error("任务提交失败", e);
    throw new CustomException("系统异常，请稍后重试");
} finally {
    // 必须释放锁
    if (lock.isHeldByCurrentThread()) {
        lock.unlock();
    }
}
```

**异常设计原则：**
- 业务异常：用户可理解的错误信息，不记录堆栈
- 系统异常：记录完整堆栈，返回友好提示
- 资源清理：使用finally或try-with-resources

---

## 14. 项目架构与业务流程

**Q：请画出系统的整体架构图？完整的业务流程是什么？**

**A：前后端分离 + 异步任务处理架构**

**系统架构：**
```
用户浏览器
    ↓ HTTP请求（提交任务）
Spring Boot Controller
    ↓
Service层（业务处理）
    ↓ 翻译提示词
Ollama AI（中译英）
    ↓
加入Redis队列（ZSet）
    ↓
定时任务扫描（每秒）
    ↓ 获取信号量
提交ComfyUI（AI生成）
    ↓ WebSocket推送
ComfyUI → Spring Boot（接收状态）
    ↓ 业务处理（保存、扣费）
Spring Boot → 前端（WebSocket推送）
    ↓
用户收到结果
```

**完整业务流程：**

**第1步：提交任务**
```
1. 用户填写表单（提示词、模型、尺寸、步数等）
2. 前端发送HTTP POST请求
3. Controller接收参数，调用Service
4. 拦截器从Token解析用户信息，存入ThreadLocal
```

**第2步：参数校验与积分冻结**
```
5. 校验参数：提示词不能为空、图片数量1-4张
6. 检查用户余额：至少需要10积分
7. 冻结积分：可用账户 → 冻结账户（10积分/张）
8. 生成任务ID（tempId = UUID）
```

**第3步：翻译与入队**
```
9. 调用Ollama AI翻译提示词（中文 → 英文）
10. 使用Freemarker渲染工作流JSON
11. 构造Task对象，保存到Redis（key=task:{tempId}）
12. 加入优先级队列（ZADD queue:text2image <时间戳> <tempId>）
13. 立即返回给前端（任务ID和排队位置）
```

**第4步：定时扫描**
```
14. 定时任务每秒执行（@Scheduled(fixedRate = 1000)）
15. 尝试获取分布式锁（防止多实例重复执行）
16. 检查队列是否有任务（ZCARD > 0）
17. 尝试获取信号量（semaphore.tryAcquire()）
```

**第5步：提交AI任务**
```
18. 从队列取出最高优先级任务（ZPOPMIN）
19. 获取任务详情（GET task:{tempId}）
20. 通过Retrofit调用ComfyUI的/prompt接口
21. 提交工作流JSON
```

**第6步：接收进度**
```
22. ComfyUI通过WebSocket推送progress消息
23. ComfyuiMessageHandler接收消息
24. 解析进度（当前步数/总步数）
25. 通过STOMP推送给前端用户
26. 前端实时更新进度条
```

**第7步：任务完成**
```
27. ComfyUI推送executed消息（包含图片信息）
28. 解析图片URL列表
29. 批量保存到user_result表
30. 从冻结账户扣除积分到系统总账户
31. 释放信号量（semaphore.release()）
32. 推送完成消息给前端（包含图片URL）
```

**第8步：展示结果**
```
33. 前端收到消息，显示生成的图片
34. 用户可以下载、收藏图片
35. 查看生图历史记录
```

**异常流程：**
```
任务失败：
→ ComfyUI推送execution_error消息
→ 归还冻结积分到可用账户
→ 释放信号量
→ 推送失败消息给前端

任务取消：
→ 用户点击取消按钮
→ 从队列删除任务（ZREM）
→ 归还冻结积分
→ 推送取消消息
```

---

## 15. Retrofit HTTP客户端

**Q：为什么用Retrofit？如何封装的？**

**A：类型安全的HTTP客户端，基于注解声明式调用**

**为什么用Retrofit：**
- 类型安全：编译期检查，避免运行时错误
- 声明式API：用注解描述接口，代码简洁
- 自动序列化：支持JSON/XML转换（Jackson/Gson）
- 支持同步/异步调用
- 可配置拦截器、超时、重试等

**接口定义：**
```java
public interface ComfyuiApi {
    
    // 提交任务
    @POST("/prompt")
    Call<ComfyuiResponse> prompt(@Body ComfyuiRequest request);
    
    // 查询队列
    @GET("/queue")
    Call<QueueResponse> getQueue();
    
    // 中断任务
    @POST("/interrupt")
    Call<Void> interrupt();
    
    // 获取图片
    @GET("/view")
    Call<ResponseBody> getImage(@Query("filename") String filename);
}
```

**配置类：**
```java
@Configuration
public class ComfyuiConfig {
    
    @Bean
    public ComfyuiApi comfyuiApi() {
        // 日志拦截器
        HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor();
        loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
        
        // OkHttp客户端
        OkHttpClient okHttpClient = new OkHttpClient.Builder()
            .addInterceptor(loggingInterceptor)
            .retryOnConnectionFailure(true)
            .callTimeout(Duration.ofSeconds(30))
            .readTimeout(Duration.ofSeconds(30))
            .build();
        
        // Retrofit客户端
        Retrofit retrofit = new Retrofit.Builder()
            .baseUrl("http://192.168.100.129:8188/")
            .client(okHttpClient)
            .addConverterFactory(JacksonConverterFactory.create())
            .build();
        
        return retrofit.create(ComfyuiApi.class);
    }
}
```

**使用示例：**
```java
@Service
public class TaskServiceImpl {
    
    @Autowired
    private ComfyuiApi comfyuiApi;
    
    public void submitTask(String workflow) {
        ComfyuiRequest request = new ComfyuiRequest();
        request.setPrompt(workflow);
        request.setClientId(Constants.COMFYUI_CLIENT_ID);
        
        try {
            // 同步调用
            Response<ComfyuiResponse> response = comfyuiApi.prompt(request).execute();
            if (response.isSuccessful()) {
                String promptId = response.body().getPromptId();
                log.info("任务提交成功: {}", promptId);
            }
        } catch (IOException e) {
            log.error("任务提交失败", e);
            throw new CustomException("ComfyUI服务异常");
        }
    }
}
```

**与RestTemplate对比：**
```
Retrofit：
+ 类型安全，编译期检查
+ 声明式，代码简洁
+ 自动转换（JSON → POJO）
- 需要定义接口

RestTemplate：
+ Spring原生，开箱即用
+ 灵活，适合简单场景
- 运行时错误，不够安全
- 代码冗长
```

---

## 16. Freemarker模板引擎

**Q：Freemarker在项目中的作用是什么？**

**A：动态生成ComfyUI工作流JSON**

**为什么用Freemarker：**
- ComfyUI的工作流JSON很复杂（节点、连接、参数）
- 大部分内容是固定的，只有少量参数需要替换
- 模板化可以降低复杂度，提高可维护性

**模板示例（t2i.ftlh）：**
```json
{
  "3": {
    "class_type": "KSampler",
    "inputs": {
      "seed": ${seed},
      "steps": ${steps},
      "cfg": ${cfg},
      "sampler_name": "${samplerName}",
      "scheduler": "${scheduler}",
      "denoise": 1,
      "model": ["4", 0],
      "positive": ["6", 0],
      "negative": ["7", 0],
      "latent_image": ["5", 0]
    }
  },
  "6": {
    "class_type": "CLIPTextEncode",
    "inputs": {
      "text": "${prompt}",
      "clip": ["4", 1]
    }
  },
  "7": {
    "class_type": "CLIPTextEncode",
    "inputs": {
      "text": "${negativePrompt}",
      "clip": ["4", 1]
    }
  }
}
```

**Service实现：**
```java
@Service
public class FreemarkerServiceImpl implements FreemarkerService {
    
    @Autowired
    private Configuration freemarkerConfig;
    
    @Override
    public String renderText2Image(ComfyuiModel model) throws Exception {
        // 加载模板
        Template template = freemarkerConfig.getTemplate("t2i.ftlh");
        
        // 准备数据
        Map<String, Object> dataModel = new HashMap<>();
        dataModel.put("seed", model.getSeed());
        dataModel.put("steps", model.getSteps());
        dataModel.put("prompt", model.getPrompt());
        dataModel.put("negativePrompt", model.getNegativePrompt());
        // ... 其他参数
        
        // 渲染
        StringWriter writer = new StringWriter();
        template.process(dataModel, writer);
        
        return writer.toString();
    }
}
```

**配置类：**
```java
@Configuration
public class FreemarkerConfig {
    
    @Bean
    public Configuration freemarkerConfiguration() {
        Configuration config = new Configuration(Configuration.VERSION_2_3_31);
        config.setClassForTemplateLoading(this.getClass(), "/templates");
        config.setDefaultEncoding("UTF-8");
        return config;
    }
}
```

**优势：**
- 模板与代码分离，便于维护
- 支持条件判断、循环等逻辑
- 可以快速适配不同的ComfyUI版本

---

## 17. MyBatis Plus自动填充

**Q：如何统一管理创建时间和更新时间？**

**A：使用MyBatis Plus的AutoFillMetaObjectHandler**

**实现类：**
```java
@Component
public class MyMetaObjectHandler implements MetaObjectHandler {
    
    @Override
    public void insertFill(MetaObject metaObject) {
        // 插入时自动填充创建时间和更新时间
        this.strictInsertFill(metaObject, "createdTime", LocalDateTime.class, LocalDateTime.now());
        this.strictInsertFill(metaObject, "updatedTime", LocalDateTime.class, LocalDateTime.now());
    }
    
    @Override
    public void updateFill(MetaObject metaObject) {
        // 更新时自动填充更新时间
        this.strictUpdateFill(metaObject, "updatedTime", LocalDateTime.class, LocalDateTime.now());
    }
}
```

**实体类配置：**
```java
@Data
@TableName("sg_user_result")
public class UserResult {
    
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private Long userId;
    private String url;
    private Integer collect;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createdTime;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updatedTime;
}
```

**优势：**
- 统一管理，无需手动设置
- 避免遗漏
- 代码简洁

---

## 18. JWT认证机制

**Q：如何实现用户认证？Token如何存储和传递？**

**A：使用JWT Token + 拦截器**

**Token生成：**
```java
public class JwtUtils {
    
    private static final String SECRET = "star-graph-secret-key";
    private static final long EXPIRE_TIME = 7 * 24 * 60 * 60 * 1000; // 7天
    
    public static String generateToken(User user) {
        return JWT.create()
            .withClaim("userId", user.getId())
            .withClaim("username", user.getUsername())
            .withExpiresAt(new Date(System.currentTimeMillis() + EXPIRE_TIME))
            .sign(Algorithm.HMAC256(SECRET));
    }
    
    public static User parseToken(String token) {
        DecodedJWT jwt = JWT.require(Algorithm.HMAC256(SECRET))
            .build()
            .verify(token);
        
        User user = new User();
        user.setId(jwt.getClaim("userId").asLong());
        user.setUsername(jwt.getClaim("username").asString());
        return user;
    }
}
```

**拦截器：**
```java
@Component
public class UserInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) {
        String token = request.getHeader("Authorization");
        
        if (token == null) {
            throw new CustomException("未登录");
        }
        
        try {
            User user = JwtUtils.parseToken(token);
            UserUtils.saveUser(user);
            return true;
        } catch (Exception e) {
            throw new CustomException("Token无效");
        }
    }
    
    @Override
    public void afterCompletion(...) {
        UserUtils.removeUser();
    }
}
```

**前端存储：**
- localStorage（持久化）
- 每次请求带上Authorization请求头

---

查看更多高级面试题，请参考项目文档！
